// generated by go:generate go run gen/edges.go
package graph


const (
	EndpointDependenciesEnums = "Endpoint,many,Enum,Dependencies"
)
type EndpointToEnumsEdges struct {
	Resolver EndpointToEnumsIdResolver `resolves:"Endpoint,many,Enum"`
}



func (e EndpointToEnumsEdges) Dependencies() (EnumNodeMap) {
	return e.Resolver.n.root.Enums.ByIds(e.Resolver.Dependencies()...)
}
const (
	EndpointDependenciesTypes = "Endpoint,many,Type,Dependencies"
)
type EndpointToTypesEdges struct {
	Resolver EndpointToTypesIdResolver `resolves:"Endpoint,many,Type"`
}



func (e EndpointToTypesEdges) Dependencies() (TypeNodeMap) {
	return e.Resolver.n.root.Types.ByIds(e.Resolver.Dependencies()...)
}
const (
	RelationHoldsFields = "Relation,many,Field,Holds"
)
type RelationToFieldsEdges struct {
	Resolver RelationToFieldsIdResolver `resolves:"Relation,many,Field"`
}


func (e RelationToFieldsEdges) Holds() (FieldNodeMap) {
	return e.Resolver.n.root.Fields.ByIds(e.Resolver.Holds()...)
}

const (
	TypeDependenciesEnums = "Type,many,Enum,Dependencies"
)
type TypeToEnumsEdges struct {
	Resolver TypeToEnumsIdResolver `resolves:"Type,many,Enum"`
}



func (e TypeToEnumsEdges) Dependencies() (EnumNodeMap) {
	return e.Resolver.n.root.Enums.ByIds(e.Resolver.Dependencies()...)
}
const (
	TypeHoldsFields = "Type,many,Field,Holds"
	TypeEdgedByFieldsFields = "Type,many,Field,EdgedByFields"
	TypeEdgedByListFieldsFields = "Type,many,Field,EdgedByListFields"
)
type TypeToFieldsEdges struct {
	Resolver TypeToFieldsIdResolver `resolves:"Type,many,Field"`
}


func (e TypeToFieldsEdges) Holds() (FieldNodeMap) {
	return e.Resolver.n.root.Fields.ByIds(e.Resolver.Holds()...)
}
func (e TypeToFieldsEdges) EdgedByFields() (FieldNodeMap) {
	return e.Resolver.n.root.Fields.ByIds(e.Resolver.EdgedByFields()...)
}
func (e TypeToFieldsEdges) EdgedByListFields() (FieldNodeMap) {
	return e.Resolver.n.root.Fields.ByIds(e.Resolver.EdgedByListFields()...)
}

const (
	TypeHoldsRelations = "Type,many,Relation,Holds"
)
type TypeToRelationsEdges struct {
	Resolver TypeToRelationsIdResolver `resolves:"Type,many,Relation"`
}


func (e TypeToRelationsEdges) Holds() (RelationNodeMap) {
	return e.Resolver.n.root.Relations.ByIds(e.Resolver.Holds()...)
}

const (
	TypeToOneRelationsTypes = "Type,many,Type,ToOneRelations"
	TypeToManyRelationsTypes = "Type,many,Type,ToManyRelations"
	TypeMissesTypes = "Type,many,Type,Misses"
	TypeDependenciesTypes = "Type,many,Type,Dependencies"
)
type TypeToTypesEdges struct {
	Resolver TypeToTypesIdResolver `resolves:"Type,many,Type"`
}


func (e TypeToTypesEdges) ToOneRelations() (TypeNodeMap) {
	return e.Resolver.n.root.Types.ByIds(e.Resolver.ToOneRelations()...)
}
func (e TypeToTypesEdges) ToManyRelations() (TypeNodeMap) {
	return e.Resolver.n.root.Types.ByIds(e.Resolver.ToManyRelations()...)
}

func (e TypeToTypesEdges) Misses() (TypeNodeMap) {
	return e.Resolver.n.root.Types.ByIds(e.Resolver.Misses()...)
}
func (e TypeToTypesEdges) Dependencies() (TypeNodeMap) {
	return e.Resolver.n.root.Types.ByIds(e.Resolver.Dependencies()...)
}
