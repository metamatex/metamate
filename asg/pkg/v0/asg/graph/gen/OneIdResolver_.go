// generated by go:generate go run gen/edges.go
package graph

import "fmt"

type EndpointToTypeIdResolver struct {
	n *EndpointNode
	d  map[string]NodeId
}

func NewEndpointToTypeIdResolver(n *EndpointNode) (EndpointToTypeIdResolver) {
	return EndpointToTypeIdResolver{
		n: n,
		d: map[string]NodeId{},
	}
}

func (r *EndpointToTypeIdResolver) set(name string, id NodeId) {
	id0, ok := r.d[name]
	if ok {
		panic(fmt.Sprintf("%v Endpoint edge %v already set to %v", r.n.Name(), name, id0))
	}

	r.d[name] = id
}

func (r *EndpointToTypeIdResolver) SetFor(id NodeId) (*EndpointToTypeIdResolver) {
	r.set("For", id)

	return r
}

func (r EndpointToTypeIdResolver) For()(NodeId) {
	return r.d["For"]
}

func (r *EndpointToTypeIdResolver) SetRequest(id NodeId) (*EndpointToTypeIdResolver) {
	r.set("Request", id)

	return r
}

func (r EndpointToTypeIdResolver) Request()(NodeId) {
	return r.d["Request"]
}

func (r *EndpointToTypeIdResolver) SetResponse(id NodeId) (*EndpointToTypeIdResolver) {
	r.set("Response", id)

	return r
}

func (r EndpointToTypeIdResolver) Response()(NodeId) {
	return r.d["Response"]
}


type EnumToTypeIdResolver struct {
	n *EnumNode
	d  map[string]NodeId
}

func NewEnumToTypeIdResolver(n *EnumNode) (EnumToTypeIdResolver) {
	return EnumToTypeIdResolver{
		n: n,
		d: map[string]NodeId{},
	}
}

func (r *EnumToTypeIdResolver) set(name string, id NodeId) {
	id0, ok := r.d[name]
	if ok {
		panic(fmt.Sprintf("%v Enum edge %v already set to %v", r.n.Name(), name, id0))
	}

	r.d[name] = id
}

func (r *EnumToTypeIdResolver) SetFilteredBy(id NodeId) (*EnumToTypeIdResolver) {
	r.set("FilteredBy", id)

	return r
}

func (r EnumToTypeIdResolver) FilteredBy()(NodeId) {
	return r.d["FilteredBy"]
}


type FieldToBasicTypeIdResolver struct {
	n *FieldNode
	d  map[string]NodeId
}

func NewFieldToBasicTypeIdResolver(n *FieldNode) (FieldToBasicTypeIdResolver) {
	return FieldToBasicTypeIdResolver{
		n: n,
		d: map[string]NodeId{},
	}
}

func (r *FieldToBasicTypeIdResolver) set(name string, id NodeId) {
	id0, ok := r.d[name]
	if ok {
		panic(fmt.Sprintf("%v Field edge %v already set to %v", r.n.Name(), name, id0))
	}

	r.d[name] = id
}

func (r *FieldToBasicTypeIdResolver) SetHolds(id NodeId) (*FieldToBasicTypeIdResolver) {
	r.set("Holds", id)

	return r
}

func (r FieldToBasicTypeIdResolver) Holds()(NodeId) {
	return r.d["Holds"]
}


type FieldToEnumIdResolver struct {
	n *FieldNode
	d  map[string]NodeId
}

func NewFieldToEnumIdResolver(n *FieldNode) (FieldToEnumIdResolver) {
	return FieldToEnumIdResolver{
		n: n,
		d: map[string]NodeId{},
	}
}

func (r *FieldToEnumIdResolver) set(name string, id NodeId) {
	id0, ok := r.d[name]
	if ok {
		panic(fmt.Sprintf("%v Field edge %v already set to %v", r.n.Name(), name, id0))
	}

	r.d[name] = id
}

func (r *FieldToEnumIdResolver) SetHolds(id NodeId) (*FieldToEnumIdResolver) {
	r.set("Holds", id)

	return r
}

func (r FieldToEnumIdResolver) Holds()(NodeId) {
	return r.d["Holds"]
}


type FieldToFieldIdResolver struct {
	n *FieldNode
	d  map[string]NodeId
}

func NewFieldToFieldIdResolver(n *FieldNode) (FieldToFieldIdResolver) {
	return FieldToFieldIdResolver{
		n: n,
		d: map[string]NodeId{},
	}
}

func (r *FieldToFieldIdResolver) set(name string, id NodeId) {
	id0, ok := r.d[name]
	if ok {
		panic(fmt.Sprintf("%v Field edge %v already set to %v", r.n.Name(), name, id0))
	}

	r.d[name] = id
}

func (r *FieldToFieldIdResolver) SetFor(id NodeId) (*FieldToFieldIdResolver) {
	r.set("For", id)

	return r
}

func (r FieldToFieldIdResolver) For()(NodeId) {
	return r.d["For"]
}

func (r *FieldToFieldIdResolver) SetRelatedTo(id NodeId) (*FieldToFieldIdResolver) {
	r.set("RelatedTo", id)

	return r
}

func (r FieldToFieldIdResolver) RelatedTo()(NodeId) {
	return r.d["RelatedTo"]
}


type FieldToRelationIdResolver struct {
	n *FieldNode
	d  map[string]NodeId
}

func NewFieldToRelationIdResolver(n *FieldNode) (FieldToRelationIdResolver) {
	return FieldToRelationIdResolver{
		n: n,
		d: map[string]NodeId{},
	}
}

func (r *FieldToRelationIdResolver) set(name string, id NodeId) {
	id0, ok := r.d[name]
	if ok {
		panic(fmt.Sprintf("%v Field edge %v already set to %v", r.n.Name(), name, id0))
	}

	r.d[name] = id
}

func (r *FieldToRelationIdResolver) SetRelatedThrough(id NodeId) (*FieldToRelationIdResolver) {
	r.set("RelatedThrough", id)

	return r
}

func (r FieldToRelationIdResolver) RelatedThrough()(NodeId) {
	return r.d["RelatedThrough"]
}


type FieldToTypeIdResolver struct {
	n *FieldNode
	d  map[string]NodeId
}

func NewFieldToTypeIdResolver(n *FieldNode) (FieldToTypeIdResolver) {
	return FieldToTypeIdResolver{
		n: n,
		d: map[string]NodeId{},
	}
}

func (r *FieldToTypeIdResolver) set(name string, id NodeId) {
	id0, ok := r.d[name]
	if ok {
		panic(fmt.Sprintf("%v Field edge %v already set to %v", r.n.Name(), name, id0))
	}

	r.d[name] = id
}

func (r *FieldToTypeIdResolver) SetHolds(id NodeId) (*FieldToTypeIdResolver) {
	r.set("Holds", id)

	return r
}

func (r FieldToTypeIdResolver) Holds()(NodeId) {
	return r.d["Holds"]
}

func (r *FieldToTypeIdResolver) SetHeldBy(id NodeId) (*FieldToTypeIdResolver) {
	r.set("HeldBy", id)

	return r
}

func (r FieldToTypeIdResolver) HeldBy()(NodeId) {
	return r.d["HeldBy"]
}


type FieldToPathIdResolver struct {
	n *FieldNode
	d  map[string]NodeId
}

func NewFieldToPathIdResolver(n *FieldNode) (FieldToPathIdResolver) {
	return FieldToPathIdResolver{
		n: n,
		d: map[string]NodeId{},
	}
}

func (r *FieldToPathIdResolver) set(name string, id NodeId) {
	id0, ok := r.d[name]
	if ok {
		panic(fmt.Sprintf("%v Field edge %v already set to %v", r.n.Name(), name, id0))
	}

	r.d[name] = id
}

func (r *FieldToPathIdResolver) SetBelongsTo(id NodeId) (*FieldToPathIdResolver) {
	r.set("BelongsTo", id)

	return r
}

func (r FieldToPathIdResolver) BelongsTo()(NodeId) {
	return r.d["BelongsTo"]
}


type RelationToTypeIdResolver struct {
	n *RelationNode
	d  map[string]NodeId
}

func NewRelationToTypeIdResolver(n *RelationNode) (RelationToTypeIdResolver) {
	return RelationToTypeIdResolver{
		n: n,
		d: map[string]NodeId{},
	}
}

func (r *RelationToTypeIdResolver) set(name string, id NodeId) {
	id0, ok := r.d[name]
	if ok {
		panic(fmt.Sprintf("%v Relation edge %v already set to %v", r.n.Name(), name, id0))
	}

	r.d[name] = id
}

func (r *RelationToTypeIdResolver) SetNodeA(id NodeId) (*RelationToTypeIdResolver) {
	r.set("NodeA", id)

	return r
}

func (r RelationToTypeIdResolver) NodeA()(NodeId) {
	return r.d["NodeA"]
}

func (r *RelationToTypeIdResolver) SetNodeB(id NodeId) (*RelationToTypeIdResolver) {
	r.set("NodeB", id)

	return r
}

func (r RelationToTypeIdResolver) NodeB()(NodeId) {
	return r.d["NodeB"]
}


type RelationToPathIdResolver struct {
	n *RelationNode
	d  map[string]NodeId
}

func NewRelationToPathIdResolver(n *RelationNode) (RelationToPathIdResolver) {
	return RelationToPathIdResolver{
		n: n,
		d: map[string]NodeId{},
	}
}

func (r *RelationToPathIdResolver) set(name string, id NodeId) {
	id0, ok := r.d[name]
	if ok {
		panic(fmt.Sprintf("%v Relation edge %v already set to %v", r.n.Name(), name, id0))
	}

	r.d[name] = id
}

func (r *RelationToPathIdResolver) SetActive(id NodeId) (*RelationToPathIdResolver) {
	r.set("Active", id)

	return r
}

func (r RelationToPathIdResolver) Active()(NodeId) {
	return r.d["Active"]
}

func (r *RelationToPathIdResolver) SetPassive(id NodeId) (*RelationToPathIdResolver) {
	r.set("Passive", id)

	return r
}

func (r RelationToPathIdResolver) Passive()(NodeId) {
	return r.d["Passive"]
}


type TypeToEndpointIdResolver struct {
	n *TypeNode
	d  map[string]NodeId
}

func NewTypeToEndpointIdResolver(n *TypeNode) (TypeToEndpointIdResolver) {
	return TypeToEndpointIdResolver{
		n: n,
		d: map[string]NodeId{},
	}
}

func (r *TypeToEndpointIdResolver) set(name string, id NodeId) {
	id0, ok := r.d[name]
	if ok {
		panic(fmt.Sprintf("%v Type edge %v already set to %v", r.n.Name(), name, id0))
	}

	r.d[name] = id
}

func (r *TypeToEndpointIdResolver) SetBelongsTo(id NodeId) (*TypeToEndpointIdResolver) {
	r.set("BelongsTo", id)

	return r
}

func (r TypeToEndpointIdResolver) BelongsTo()(NodeId) {
	return r.d["BelongsTo"]
}

func (r *TypeToEndpointIdResolver) SetGet(id NodeId) (*TypeToEndpointIdResolver) {
	r.set("Get", id)

	return r
}

func (r TypeToEndpointIdResolver) Get()(NodeId) {
	return r.d["Get"]
}


type TypeToEnumIdResolver struct {
	n *TypeNode
	d  map[string]NodeId
}

func NewTypeToEnumIdResolver(n *TypeNode) (TypeToEnumIdResolver) {
	return TypeToEnumIdResolver{
		n: n,
		d: map[string]NodeId{},
	}
}

func (r *TypeToEnumIdResolver) set(name string, id NodeId) {
	id0, ok := r.d[name]
	if ok {
		panic(fmt.Sprintf("%v Type edge %v already set to %v", r.n.Name(), name, id0))
	}

	r.d[name] = id
}

func (r *TypeToEnumIdResolver) SetFor(id NodeId) (*TypeToEnumIdResolver) {
	r.set("For", id)

	return r
}

func (r TypeToEnumIdResolver) For()(NodeId) {
	return r.d["For"]
}

func (r *TypeToEnumIdResolver) SetListKind(id NodeId) (*TypeToEnumIdResolver) {
	r.set("ListKind", id)

	return r
}

func (r TypeToEnumIdResolver) ListKind()(NodeId) {
	return r.d["ListKind"]
}


type TypeToTypeIdResolver struct {
	n *TypeNode
	d  map[string]NodeId
}

func NewTypeToTypeIdResolver(n *TypeNode) (TypeToTypeIdResolver) {
	return TypeToTypeIdResolver{
		n: n,
		d: map[string]NodeId{},
	}
}

func (r *TypeToTypeIdResolver) set(name string, id NodeId) {
	id0, ok := r.d[name]
	if ok {
		panic(fmt.Sprintf("%v Type edge %v already set to %v", r.n.Name(), name, id0))
	}

	r.d[name] = id
}

func (r *TypeToTypeIdResolver) SetFor(id NodeId) (*TypeToTypeIdResolver) {
	r.set("For", id)

	return r
}

func (r TypeToTypeIdResolver) For()(NodeId) {
	return r.d["For"]
}

func (r *TypeToTypeIdResolver) SetFilteredBy(id NodeId) (*TypeToTypeIdResolver) {
	r.set("FilteredBy", id)

	return r
}

func (r TypeToTypeIdResolver) FilteredBy()(NodeId) {
	return r.d["FilteredBy"]
}

func (r *TypeToTypeIdResolver) SetSortedBy(id NodeId) (*TypeToTypeIdResolver) {
	r.set("SortedBy", id)

	return r
}

func (r TypeToTypeIdResolver) SortedBy()(NodeId) {
	return r.d["SortedBy"]
}

func (r *TypeToTypeIdResolver) SetSelectedBy(id NodeId) (*TypeToTypeIdResolver) {
	r.set("SelectedBy", id)

	return r
}

func (r TypeToTypeIdResolver) SelectedBy()(NodeId) {
	return r.d["SelectedBy"]
}

func (r *TypeToTypeIdResolver) SetCollection(id NodeId) (*TypeToTypeIdResolver) {
	r.set("Collection", id)

	return r
}

func (r TypeToTypeIdResolver) Collection()(NodeId) {
	return r.d["Collection"]
}

func (r *TypeToTypeIdResolver) SetRequest(id NodeId) (*TypeToTypeIdResolver) {
	r.set("Request", id)

	return r
}

func (r TypeToTypeIdResolver) Request()(NodeId) {
	return r.d["Request"]
}

func (r *TypeToTypeIdResolver) SetResponse(id NodeId) (*TypeToTypeIdResolver) {
	r.set("Response", id)

	return r
}

func (r TypeToTypeIdResolver) Response()(NodeId) {
	return r.d["Response"]
}

func (r *TypeToTypeIdResolver) SetGetRequest(id NodeId) (*TypeToTypeIdResolver) {
	r.set("GetRequest", id)

	return r
}

func (r TypeToTypeIdResolver) GetRequest()(NodeId) {
	return r.d["GetRequest"]
}

func (r *TypeToTypeIdResolver) SetGetCollection(id NodeId) (*TypeToTypeIdResolver) {
	r.set("GetCollection", id)

	return r
}

func (r TypeToTypeIdResolver) GetCollection()(NodeId) {
	return r.d["GetCollection"]
}

func (r *TypeToTypeIdResolver) SetGetRelations(id NodeId) (*TypeToTypeIdResolver) {
	r.set("GetRelations", id)

	return r
}

func (r TypeToTypeIdResolver) GetRelations()(NodeId) {
	return r.d["GetRelations"]
}

func (r *TypeToTypeIdResolver) SetGetResponse(id NodeId) (*TypeToTypeIdResolver) {
	r.set("GetResponse", id)

	return r
}

func (r TypeToTypeIdResolver) GetResponse()(NodeId) {
	return r.d["GetResponse"]
}

func (r *TypeToTypeIdResolver) SetGetEndpoint(id NodeId) (*TypeToTypeIdResolver) {
	r.set("GetEndpoint", id)

	return r
}

func (r TypeToTypeIdResolver) GetEndpoint()(NodeId) {
	return r.d["GetEndpoint"]
}


type PathToRelationIdResolver struct {
	n *PathNode
	d  map[string]NodeId
}

func NewPathToRelationIdResolver(n *PathNode) (PathToRelationIdResolver) {
	return PathToRelationIdResolver{
		n: n,
		d: map[string]NodeId{},
	}
}

func (r *PathToRelationIdResolver) set(name string, id NodeId) {
	id0, ok := r.d[name]
	if ok {
		panic(fmt.Sprintf("%v Path edge %v already set to %v", r.n.Name(), name, id0))
	}

	r.d[name] = id
}

func (r *PathToRelationIdResolver) SetBelongsTo(id NodeId) (*PathToRelationIdResolver) {
	r.set("BelongsTo", id)

	return r
}

func (r PathToRelationIdResolver) BelongsTo()(NodeId) {
	return r.d["BelongsTo"]
}


type PathToTypeIdResolver struct {
	n *PathNode
	d  map[string]NodeId
}

func NewPathToTypeIdResolver(n *PathNode) (PathToTypeIdResolver) {
	return PathToTypeIdResolver{
		n: n,
		d: map[string]NodeId{},
	}
}

func (r *PathToTypeIdResolver) set(name string, id NodeId) {
	id0, ok := r.d[name]
	if ok {
		panic(fmt.Sprintf("%v Path edge %v already set to %v", r.n.Name(), name, id0))
	}

	r.d[name] = id
}

func (r *PathToTypeIdResolver) SetFrom(id NodeId) (*PathToTypeIdResolver) {
	r.set("From", id)

	return r
}

func (r PathToTypeIdResolver) From()(NodeId) {
	return r.d["From"]
}

func (r *PathToTypeIdResolver) SetTo(id NodeId) (*PathToTypeIdResolver) {
	r.set("To", id)

	return r
}

func (r PathToTypeIdResolver) To()(NodeId) {
	return r.d["To"]
}


