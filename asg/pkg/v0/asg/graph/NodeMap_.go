// generated by go:generate go run gen/nodemap.go
package graph

import (
	"errors"
	"fmt"
	"strings"
)

type BasicTypeNodeMap map[NodeId]*BasicTypeNode

func (nm BasicTypeNodeMap) ToNodeMap() (nm0 NodeMap) {
	nm0 = NodeMap{}

	for k, v := range nm {
		nm0[k] = v
	}

	return
}

func (nm BasicTypeNodeMap) UniqueNames() (ns []string) {
	nsm := map[string]bool{}

	for _, v := range nm {
		nsm[v.Name()] = true
	}

	for k, _ := range nsm {
		ns = append(ns, k)
	}

	return
}

func (nm BasicTypeNodeMap) Copy() (nm0 BasicTypeNodeMap) {
	nm0 = BasicTypeNodeMap{}
	for k, v := range nm {
		nm0[k] = v
	}

	return
}

func (nm BasicTypeNodeMap) Filter(s Filter) BasicTypeNodeMap {
	if s.Flags != nil {
		nm = nm.FilterByFlags(*s.Flags)
	}

	if s.Names != nil {
		nm = nm.FilterByNames(*s.Names)
	}

	return nm
}

func (nm BasicTypeNodeMap) Add(ns ...*BasicTypeNode) {
	for _, n := range ns {
		_, ok := nm[n.Id()]
		if ok {
			panic(fmt.Sprintf("BasicTypeNode %v already appended", n.Id()))
		}

		nm[n.Id()] = n
	}
}

func (nm BasicTypeNodeMap) AddBasicTypeNodeMap(nm0 BasicTypeNodeMap) (nm1 BasicTypeNodeMap) {
	nm1 = BasicTypeNodeMap{}

	for _, n := range nm {
		nm1.Add(n)
	}

	for _, n := range nm0 {
		nm1.Add(n)
	}

	return
}

func (nm BasicTypeNodeMap) ExcludeIds(ids ...NodeId) BasicTypeNodeMap {
	not := map[NodeId]bool{}

	for _, id := range ids {
		not[id] = true
	}

	return nm.FilterFunc(func(n *BasicTypeNode) bool {
		_, ok := not[n.Id()]

		return !ok
	})
}

func (nm BasicTypeNodeMap) ExcludeNames(names ...string) BasicTypeNodeMap {
	ids := []NodeId{}
	for _, name := range names {
		ids = append(ids, ToNodeId(name))
	}

	return nm.ExcludeIds(ids...)
}

func (nm BasicTypeNodeMap) ByIds(ids ...NodeId) (filtered BasicTypeNodeMap) {
	filtered = BasicTypeNodeMap{}

	for _, id := range ids {
		filtered[id] = nm.MustById(id)
	}

	return
}

func (nm BasicTypeNodeMap) ByNames(names ...string) BasicTypeNodeMap {
	ids := []NodeId{}
	for _, name := range names {
		ids = append(ids, ToNodeId(name))
	}

	return nm.ByIds(ids...)
}

func (nm BasicTypeNodeMap) ById(id NodeId) (n *BasicTypeNode, err error) {
	n, ok := nm[id]
	if !ok {
		err = errors.New(fmt.Sprintf("BasicType node id %v not found", id))
	}

	return
}

func (nm BasicTypeNodeMap) MustById(id NodeId) (n *BasicTypeNode) {
	n, err := nm.ById(id)
	if err != nil {
		panic(err)
	}

	return
}

func (nm BasicTypeNodeMap) ByName(name string) (*BasicTypeNode, error) {
	name = strings.ToLower(name)
	for _, fn := range nm {
		if strings.ToLower(fn.Name()) == name {
			return fn, nil
		}
	}

	return nil, errors.New(fmt.Sprintf("BasicType node name %v not found", name))
}

func (nm BasicTypeNodeMap) MustByName(name string) (n *BasicTypeNode) {
	n, err := nm.ByName(name)
	if err != nil {
		panic(err)
	}

	return
}

func (nm BasicTypeNodeMap) Each(f func(n *BasicTypeNode)) {
	for _, n := range nm {
		f(n)
	}
}

func (nm BasicTypeNodeMap) FilterFunc(f func(n *BasicTypeNode) bool) (nm0 BasicTypeNodeMap) {
	nm0 = BasicTypeNodeMap{}

	for _, n := range nm {
		if f(n) {
			nm0[n.Id()] = n
		}
	}

	return
}

func (nm BasicTypeNodeMap) HasId(id NodeId) bool {
	_, ok := nm[id]

	return ok
}

func (nm BasicTypeNodeMap) HasName(name string) bool {
	return nm.HasId(ToNodeId(name))
}

func (nm BasicTypeNodeMap) BroadcastSetFlag(name string, v bool) {
	for _, n := range nm {
		n.Flags().Set(name, v)
	}

	return
}

func (nm BasicTypeNodeMap) GetIds() (ids []NodeId) {
	for k, _ := range nm {
		ids = append(ids, k)
	}

	return
}

func (nm BasicTypeNodeMap) Flagged(flag string, b bool) (nm0 BasicTypeNodeMap) {
	nm0 = BasicTypeNodeMap{}

	for k, n := range nm {
		if n.Flags().Is(flag, b) {
			nm0[k] = n
		}
	}

	return
}

func (nm BasicTypeNodeMap) FilterByFlags(subset FlagsSubset) BasicTypeNodeMap {
	if len(subset.Or) != 0 {
		var tfs []string
		for _, f := range subset.Or {
			tfs = append(tfs, string(f))
		}

		nm = nm.FlaggedOr(tfs...)
	}

	if len(subset.And) != 0 {
		for _, f := range subset.And {
			nm = nm.Flagged(string(f), true)
		}
	}

	for _, f := range subset.Nor {
		nm = nm.Flagged(string(f), false)
	}

	if len(nm) == 0 {
		panic("no nodes")
	}

	return nm
}

func (nm BasicTypeNodeMap) FilterByNames(subset NamesSubset) BasicTypeNodeMap {
	if len(subset.Or) != 0 {
		nm = nm.ByNames(subset.Or...)
	}

	if len(subset.Nor) != 0 {
		nm = nm.ExcludeNames(subset.Nor...)
	}

	if len(subset.ContainsOr) != 0 {
		nm = nm.FilterFunc(func(n *BasicTypeNode) bool {
			for _, c := range subset.ContainsOr {
				if strings.Contains(n.Name(), c) {
					return true
				}
			}

			return false
		})
	}

	if len(nm) == 0 {
		panic("no BasicTypes")
	}

	return nm
}

func (nm BasicTypeNodeMap) FlaggedOr(fs ...string) (nm0 BasicTypeNodeMap) {
	nm0 = BasicTypeNodeMap{}

	for k, n := range nm {
		if n.Flags().Or(fs...) {
			nm0[k] = n
		}
	}

	return
}

func (nm BasicTypeNodeMap) BroadcastPrint() {
	for _, n := range nm {
		n.Print()
		println("- - - - - - - - - -")
	}

	return
}

func (nm BasicTypeNodeMap) Slice() (ns BasicTypeNodeSlice) {
	for _, n := range nm {
		ns = append(ns, n)
	}

	return
}

type EndpointNodeMap map[NodeId]*EndpointNode

func (nm EndpointNodeMap) ToNodeMap() (nm0 NodeMap) {
	nm0 = NodeMap{}

	for k, v := range nm {
		nm0[k] = v
	}

	return
}

func (nm EndpointNodeMap) UniqueNames() (ns []string) {
	nsm := map[string]bool{}

	for _, v := range nm {
		nsm[v.Name()] = true
	}

	for k, _ := range nsm {
		ns = append(ns, k)
	}

	return
}

func (nm EndpointNodeMap) Copy() (nm0 EndpointNodeMap) {
	nm0 = EndpointNodeMap{}
	for k, v := range nm {
		nm0[k] = v
	}

	return
}

func (nm EndpointNodeMap) Filter(s Filter) EndpointNodeMap {
	if s.Flags != nil {
		nm = nm.FilterByFlags(*s.Flags)
	}

	if s.Names != nil {
		nm = nm.FilterByNames(*s.Names)
	}

	return nm
}

func (nm EndpointNodeMap) Add(ns ...*EndpointNode) {
	for _, n := range ns {
		_, ok := nm[n.Id()]
		if ok {
			panic(fmt.Sprintf("EndpointNode %v already appended", n.Id()))
		}

		nm[n.Id()] = n
	}
}

func (nm EndpointNodeMap) AddEndpointNodeMap(nm0 EndpointNodeMap) (nm1 EndpointNodeMap) {
	nm1 = EndpointNodeMap{}

	for _, n := range nm {
		nm1.Add(n)
	}

	for _, n := range nm0 {
		nm1.Add(n)
	}

	return
}

func (nm EndpointNodeMap) ExcludeIds(ids ...NodeId) EndpointNodeMap {
	not := map[NodeId]bool{}

	for _, id := range ids {
		not[id] = true
	}

	return nm.FilterFunc(func(n *EndpointNode) bool {
		_, ok := not[n.Id()]

		return !ok
	})
}

func (nm EndpointNodeMap) ExcludeNames(names ...string) EndpointNodeMap {
	ids := []NodeId{}
	for _, name := range names {
		ids = append(ids, ToNodeId(name))
	}

	return nm.ExcludeIds(ids...)
}

func (nm EndpointNodeMap) ByIds(ids ...NodeId) (filtered EndpointNodeMap) {
	filtered = EndpointNodeMap{}

	for _, id := range ids {
		filtered[id] = nm.MustById(id)
	}

	return
}

func (nm EndpointNodeMap) ByNames(names ...string) EndpointNodeMap {
	ids := []NodeId{}
	for _, name := range names {
		ids = append(ids, ToNodeId(name))
	}

	return nm.ByIds(ids...)
}

func (nm EndpointNodeMap) ById(id NodeId) (n *EndpointNode, err error) {
	n, ok := nm[id]
	if !ok {
		err = errors.New(fmt.Sprintf("Endpoint node id %v not found", id))
	}

	return
}

func (nm EndpointNodeMap) MustById(id NodeId) (n *EndpointNode) {
	n, err := nm.ById(id)
	if err != nil {
		panic(err)
	}

	return
}

func (nm EndpointNodeMap) ByName(name string) (*EndpointNode, error) {
	name = strings.ToLower(name)
	for _, fn := range nm {
		if strings.ToLower(fn.Name()) == name {
			return fn, nil
		}
	}

	return nil, errors.New(fmt.Sprintf("Endpoint node name %v not found", name))
}

func (nm EndpointNodeMap) MustByName(name string) (n *EndpointNode) {
	n, err := nm.ByName(name)
	if err != nil {
		panic(err)
	}

	return
}

func (nm EndpointNodeMap) Each(f func(n *EndpointNode)) {
	for _, n := range nm {
		f(n)
	}
}

func (nm EndpointNodeMap) FilterFunc(f func(n *EndpointNode) bool) (nm0 EndpointNodeMap) {
	nm0 = EndpointNodeMap{}

	for _, n := range nm {
		if f(n) {
			nm0[n.Id()] = n
		}
	}

	return
}

func (nm EndpointNodeMap) HasId(id NodeId) bool {
	_, ok := nm[id]

	return ok
}

func (nm EndpointNodeMap) HasName(name string) bool {
	return nm.HasId(ToNodeId(name))
}

func (nm EndpointNodeMap) BroadcastSetFlag(name string, v bool) {
	for _, n := range nm {
		n.Flags().Set(name, v)
	}

	return
}

func (nm EndpointNodeMap) GetIds() (ids []NodeId) {
	for k, _ := range nm {
		ids = append(ids, k)
	}

	return
}

func (nm EndpointNodeMap) Flagged(flag string, b bool) (nm0 EndpointNodeMap) {
	nm0 = EndpointNodeMap{}

	for k, n := range nm {
		if n.Flags().Is(flag, b) {
			nm0[k] = n
		}
	}

	return
}

func (nm EndpointNodeMap) FilterByFlags(subset FlagsSubset) EndpointNodeMap {
	if len(subset.Or) != 0 {
		var tfs []string
		for _, f := range subset.Or {
			tfs = append(tfs, string(f))
		}

		nm = nm.FlaggedOr(tfs...)
	}

	if len(subset.And) != 0 {
		for _, f := range subset.And {
			nm = nm.Flagged(string(f), true)
		}
	}

	for _, f := range subset.Nor {
		nm = nm.Flagged(string(f), false)
	}

	if len(nm) == 0 {
		panic("no nodes")
	}

	return nm
}

func (nm EndpointNodeMap) FilterByNames(subset NamesSubset) EndpointNodeMap {
	if len(subset.Or) != 0 {
		nm = nm.ByNames(subset.Or...)
	}

	if len(subset.Nor) != 0 {
		nm = nm.ExcludeNames(subset.Nor...)
	}

	if len(subset.ContainsOr) != 0 {
		nm = nm.FilterFunc(func(n *EndpointNode) bool {
			for _, c := range subset.ContainsOr {
				if strings.Contains(n.Name(), c) {
					return true
				}
			}

			return false
		})
	}

	if len(nm) == 0 {
		panic("no Endpoints")
	}

	return nm
}

func (nm EndpointNodeMap) FlaggedOr(fs ...string) (nm0 EndpointNodeMap) {
	nm0 = EndpointNodeMap{}

	for k, n := range nm {
		if n.Flags().Or(fs...) {
			nm0[k] = n
		}
	}

	return
}

func (nm EndpointNodeMap) BroadcastPrint() {
	for _, n := range nm {
		n.Print()
		println("- - - - - - - - - -")
	}

	return
}

func (nm EndpointNodeMap) Slice() (ns EndpointNodeSlice) {
	for _, n := range nm {
		ns = append(ns, n)
	}

	return
}

type EnumNodeMap map[NodeId]*EnumNode

func (nm EnumNodeMap) ToNodeMap() (nm0 NodeMap) {
	nm0 = NodeMap{}

	for k, v := range nm {
		nm0[k] = v
	}

	return
}

func (nm EnumNodeMap) UniqueNames() (ns []string) {
	nsm := map[string]bool{}

	for _, v := range nm {
		nsm[v.Name()] = true
	}

	for k, _ := range nsm {
		ns = append(ns, k)
	}

	return
}

func (nm EnumNodeMap) Copy() (nm0 EnumNodeMap) {
	nm0 = EnumNodeMap{}
	for k, v := range nm {
		nm0[k] = v
	}

	return
}

func (nm EnumNodeMap) Filter(s Filter) EnumNodeMap {
	if s.Flags != nil {
		nm = nm.FilterByFlags(*s.Flags)
	}

	if s.Names != nil {
		nm = nm.FilterByNames(*s.Names)
	}

	return nm
}

func (nm EnumNodeMap) Add(ns ...*EnumNode) {
	for _, n := range ns {
		_, ok := nm[n.Id()]
		if ok {
			panic(fmt.Sprintf("EnumNode %v already appended", n.Id()))
		}

		nm[n.Id()] = n
	}
}

func (nm EnumNodeMap) AddEnumNodeMap(nm0 EnumNodeMap) (nm1 EnumNodeMap) {
	nm1 = EnumNodeMap{}

	for _, n := range nm {
		nm1.Add(n)
	}

	for _, n := range nm0 {
		nm1.Add(n)
	}

	return
}

func (nm EnumNodeMap) ExcludeIds(ids ...NodeId) EnumNodeMap {
	not := map[NodeId]bool{}

	for _, id := range ids {
		not[id] = true
	}

	return nm.FilterFunc(func(n *EnumNode) bool {
		_, ok := not[n.Id()]

		return !ok
	})
}

func (nm EnumNodeMap) ExcludeNames(names ...string) EnumNodeMap {
	ids := []NodeId{}
	for _, name := range names {
		ids = append(ids, ToNodeId(name))
	}

	return nm.ExcludeIds(ids...)
}

func (nm EnumNodeMap) ByIds(ids ...NodeId) (filtered EnumNodeMap) {
	filtered = EnumNodeMap{}

	for _, id := range ids {
		filtered[id] = nm.MustById(id)
	}

	return
}

func (nm EnumNodeMap) ByNames(names ...string) EnumNodeMap {
	ids := []NodeId{}
	for _, name := range names {
		ids = append(ids, ToNodeId(name))
	}

	return nm.ByIds(ids...)
}

func (nm EnumNodeMap) ById(id NodeId) (n *EnumNode, err error) {
	n, ok := nm[id]
	if !ok {
		err = errors.New(fmt.Sprintf("Enum node id %v not found", id))
	}

	return
}

func (nm EnumNodeMap) MustById(id NodeId) (n *EnumNode) {
	n, err := nm.ById(id)
	if err != nil {
		panic(err)
	}

	return
}

func (nm EnumNodeMap) ByName(name string) (*EnumNode, error) {
	name = strings.ToLower(name)
	for _, fn := range nm {
		if strings.ToLower(fn.Name()) == name {
			return fn, nil
		}
	}

	return nil, errors.New(fmt.Sprintf("Enum node name %v not found", name))
}

func (nm EnumNodeMap) MustByName(name string) (n *EnumNode) {
	n, err := nm.ByName(name)
	if err != nil {
		panic(err)
	}

	return
}

func (nm EnumNodeMap) Each(f func(n *EnumNode)) {
	for _, n := range nm {
		f(n)
	}
}

func (nm EnumNodeMap) FilterFunc(f func(n *EnumNode) bool) (nm0 EnumNodeMap) {
	nm0 = EnumNodeMap{}

	for _, n := range nm {
		if f(n) {
			nm0[n.Id()] = n
		}
	}

	return
}

func (nm EnumNodeMap) HasId(id NodeId) bool {
	_, ok := nm[id]

	return ok
}

func (nm EnumNodeMap) HasName(name string) bool {
	return nm.HasId(ToNodeId(name))
}

func (nm EnumNodeMap) BroadcastSetFlag(name string, v bool) {
	for _, n := range nm {
		n.Flags().Set(name, v)
	}

	return
}

func (nm EnumNodeMap) GetIds() (ids []NodeId) {
	for k, _ := range nm {
		ids = append(ids, k)
	}

	return
}

func (nm EnumNodeMap) Flagged(flag string, b bool) (nm0 EnumNodeMap) {
	nm0 = EnumNodeMap{}

	for k, n := range nm {
		if n.Flags().Is(flag, b) {
			nm0[k] = n
		}
	}

	return
}

func (nm EnumNodeMap) FilterByFlags(subset FlagsSubset) EnumNodeMap {
	if len(subset.Or) != 0 {
		var tfs []string
		for _, f := range subset.Or {
			tfs = append(tfs, string(f))
		}

		nm = nm.FlaggedOr(tfs...)
	}

	if len(subset.And) != 0 {
		for _, f := range subset.And {
			nm = nm.Flagged(string(f), true)
		}
	}

	for _, f := range subset.Nor {
		nm = nm.Flagged(string(f), false)
	}

	if len(nm) == 0 {
		panic("no nodes")
	}

	return nm
}

func (nm EnumNodeMap) FilterByNames(subset NamesSubset) EnumNodeMap {
	if len(subset.Or) != 0 {
		nm = nm.ByNames(subset.Or...)
	}

	if len(subset.Nor) != 0 {
		nm = nm.ExcludeNames(subset.Nor...)
	}

	if len(subset.ContainsOr) != 0 {
		nm = nm.FilterFunc(func(n *EnumNode) bool {
			for _, c := range subset.ContainsOr {
				if strings.Contains(n.Name(), c) {
					return true
				}
			}

			return false
		})
	}

	if len(nm) == 0 {
		panic("no Enums")
	}

	return nm
}

func (nm EnumNodeMap) FlaggedOr(fs ...string) (nm0 EnumNodeMap) {
	nm0 = EnumNodeMap{}

	for k, n := range nm {
		if n.Flags().Or(fs...) {
			nm0[k] = n
		}
	}

	return
}

func (nm EnumNodeMap) BroadcastPrint() {
	for _, n := range nm {
		n.Print()
		println("- - - - - - - - - -")
	}

	return
}

func (nm EnumNodeMap) Slice() (ns EnumNodeSlice) {
	for _, n := range nm {
		ns = append(ns, n)
	}

	return
}

type FieldNodeMap map[NodeId]*FieldNode

func (nm FieldNodeMap) ToNodeMap() (nm0 NodeMap) {
	nm0 = NodeMap{}

	for k, v := range nm {
		nm0[k] = v
	}

	return
}

func (nm FieldNodeMap) UniqueNames() (ns []string) {
	nsm := map[string]bool{}

	for _, v := range nm {
		nsm[v.Name()] = true
	}

	for k, _ := range nsm {
		ns = append(ns, k)
	}

	return
}

func (nm FieldNodeMap) Copy() (nm0 FieldNodeMap) {
	nm0 = FieldNodeMap{}
	for k, v := range nm {
		nm0[k] = v
	}

	return
}

func (nm FieldNodeMap) Filter(s Filter) FieldNodeMap {
	if s.Flags != nil {
		nm = nm.FilterByFlags(*s.Flags)
	}

	if s.Names != nil {
		nm = nm.FilterByNames(*s.Names)
	}

	return nm
}

func (nm FieldNodeMap) Add(ns ...*FieldNode) {
	for _, n := range ns {
		_, ok := nm[n.Id()]
		if ok {
			panic(fmt.Sprintf("FieldNode %v already appended", n.Id()))
		}

		nm[n.Id()] = n
	}
}

func (nm FieldNodeMap) AddFieldNodeMap(nm0 FieldNodeMap) (nm1 FieldNodeMap) {
	nm1 = FieldNodeMap{}

	for _, n := range nm {
		nm1.Add(n)
	}

	for _, n := range nm0 {
		nm1.Add(n)
	}

	return
}

func (nm FieldNodeMap) ExcludeIds(ids ...NodeId) FieldNodeMap {
	not := map[NodeId]bool{}

	for _, id := range ids {
		not[id] = true
	}

	return nm.FilterFunc(func(n *FieldNode) bool {
		_, ok := not[n.Id()]

		return !ok
	})
}

func (nm FieldNodeMap) ExcludeNames(names ...string) FieldNodeMap {
	ids := []NodeId{}
	for _, name := range names {
		ids = append(ids, ToNodeId(name))
	}

	return nm.ExcludeIds(ids...)
}

func (nm FieldNodeMap) ByIds(ids ...NodeId) (filtered FieldNodeMap) {
	filtered = FieldNodeMap{}

	for _, id := range ids {
		filtered[id] = nm.MustById(id)
	}

	return
}

func (nm FieldNodeMap) ByNames(names ...string) FieldNodeMap {
	ids := []NodeId{}
	for _, name := range names {
		ids = append(ids, ToNodeId(name))
	}

	return nm.ByIds(ids...)
}

func (nm FieldNodeMap) ById(id NodeId) (n *FieldNode, err error) {
	n, ok := nm[id]
	if !ok {
		err = errors.New(fmt.Sprintf("Field node id %v not found", id))
	}

	return
}

func (nm FieldNodeMap) MustById(id NodeId) (n *FieldNode) {
	n, err := nm.ById(id)
	if err != nil {
		panic(err)
	}

	return
}

func (nm FieldNodeMap) ByName(name string) (*FieldNode, error) {
	name = strings.ToLower(name)
	for _, fn := range nm {
		if strings.ToLower(fn.Name()) == name {
			return fn, nil
		}
	}

	return nil, errors.New(fmt.Sprintf("Field node name %v not found", name))
}

func (nm FieldNodeMap) MustByName(name string) (n *FieldNode) {
	n, err := nm.ByName(name)
	if err != nil {
		panic(err)
	}

	return
}

func (nm FieldNodeMap) Each(f func(n *FieldNode)) {
	for _, n := range nm {
		f(n)
	}
}

func (nm FieldNodeMap) FilterFunc(f func(n *FieldNode) bool) (nm0 FieldNodeMap) {
	nm0 = FieldNodeMap{}

	for _, n := range nm {
		if f(n) {
			nm0[n.Id()] = n
		}
	}

	return
}

func (nm FieldNodeMap) HasId(id NodeId) bool {
	_, ok := nm[id]

	return ok
}

func (nm FieldNodeMap) HasName(name string) bool {
	return nm.HasId(ToNodeId(name))
}

func (nm FieldNodeMap) BroadcastSetFlag(name string, v bool) {
	for _, n := range nm {
		n.Flags().Set(name, v)
	}

	return
}

func (nm FieldNodeMap) GetIds() (ids []NodeId) {
	for k, _ := range nm {
		ids = append(ids, k)
	}

	return
}

func (nm FieldNodeMap) Flagged(flag string, b bool) (nm0 FieldNodeMap) {
	nm0 = FieldNodeMap{}

	for k, n := range nm {
		if n.Flags().Is(flag, b) {
			nm0[k] = n
		}
	}

	return
}

func (nm FieldNodeMap) FilterByFlags(subset FlagsSubset) FieldNodeMap {
	if len(subset.Or) != 0 {
		var tfs []string
		for _, f := range subset.Or {
			tfs = append(tfs, string(f))
		}

		nm = nm.FlaggedOr(tfs...)
	}

	if len(subset.And) != 0 {
		for _, f := range subset.And {
			nm = nm.Flagged(string(f), true)
		}
	}

	for _, f := range subset.Nor {
		nm = nm.Flagged(string(f), false)
	}

	if len(nm) == 0 {
		panic("no nodes")
	}

	return nm
}

func (nm FieldNodeMap) FilterByNames(subset NamesSubset) FieldNodeMap {
	if len(subset.Or) != 0 {
		nm = nm.ByNames(subset.Or...)
	}

	if len(subset.Nor) != 0 {
		nm = nm.ExcludeNames(subset.Nor...)
	}

	if len(subset.ContainsOr) != 0 {
		nm = nm.FilterFunc(func(n *FieldNode) bool {
			for _, c := range subset.ContainsOr {
				if strings.Contains(n.Name(), c) {
					return true
				}
			}

			return false
		})
	}

	if len(nm) == 0 {
		panic("no Fields")
	}

	return nm
}

func (nm FieldNodeMap) FlaggedOr(fs ...string) (nm0 FieldNodeMap) {
	nm0 = FieldNodeMap{}

	for k, n := range nm {
		if n.Flags().Or(fs...) {
			nm0[k] = n
		}
	}

	return
}

func (nm FieldNodeMap) BroadcastPrint() {
	for _, n := range nm {
		n.Print()
		println("- - - - - - - - - -")
	}

	return
}

func (nm FieldNodeMap) Slice() (ns FieldNodeSlice) {
	for _, n := range nm {
		ns = append(ns, n)
	}

	return
}

type RelationNodeMap map[NodeId]*RelationNode

func (nm RelationNodeMap) ToNodeMap() (nm0 NodeMap) {
	nm0 = NodeMap{}

	for k, v := range nm {
		nm0[k] = v
	}

	return
}

func (nm RelationNodeMap) UniqueNames() (ns []string) {
	nsm := map[string]bool{}

	for _, v := range nm {
		nsm[v.Name()] = true
	}

	for k, _ := range nsm {
		ns = append(ns, k)
	}

	return
}

func (nm RelationNodeMap) Copy() (nm0 RelationNodeMap) {
	nm0 = RelationNodeMap{}
	for k, v := range nm {
		nm0[k] = v
	}

	return
}

func (nm RelationNodeMap) Filter(s Filter) RelationNodeMap {
	if s.Flags != nil {
		nm = nm.FilterByFlags(*s.Flags)
	}

	if s.Names != nil {
		nm = nm.FilterByNames(*s.Names)
	}

	return nm
}

func (nm RelationNodeMap) Add(ns ...*RelationNode) {
	for _, n := range ns {
		_, ok := nm[n.Id()]
		if ok {
			panic(fmt.Sprintf("RelationNode %v already appended", n.Id()))
		}

		nm[n.Id()] = n
	}
}

func (nm RelationNodeMap) AddRelationNodeMap(nm0 RelationNodeMap) (nm1 RelationNodeMap) {
	nm1 = RelationNodeMap{}

	for _, n := range nm {
		nm1.Add(n)
	}

	for _, n := range nm0 {
		nm1.Add(n)
	}

	return
}

func (nm RelationNodeMap) ExcludeIds(ids ...NodeId) RelationNodeMap {
	not := map[NodeId]bool{}

	for _, id := range ids {
		not[id] = true
	}

	return nm.FilterFunc(func(n *RelationNode) bool {
		_, ok := not[n.Id()]

		return !ok
	})
}

func (nm RelationNodeMap) ExcludeNames(names ...string) RelationNodeMap {
	ids := []NodeId{}
	for _, name := range names {
		ids = append(ids, ToNodeId(name))
	}

	return nm.ExcludeIds(ids...)
}

func (nm RelationNodeMap) ByIds(ids ...NodeId) (filtered RelationNodeMap) {
	filtered = RelationNodeMap{}

	for _, id := range ids {
		filtered[id] = nm.MustById(id)
	}

	return
}

func (nm RelationNodeMap) ByNames(names ...string) RelationNodeMap {
	ids := []NodeId{}
	for _, name := range names {
		ids = append(ids, ToNodeId(name))
	}

	return nm.ByIds(ids...)
}

func (nm RelationNodeMap) ById(id NodeId) (n *RelationNode, err error) {
	n, ok := nm[id]
	if !ok {
		err = errors.New(fmt.Sprintf("Relation node id %v not found", id))
	}

	return
}

func (nm RelationNodeMap) MustById(id NodeId) (n *RelationNode) {
	n, err := nm.ById(id)
	if err != nil {
		panic(err)
	}

	return
}

func (nm RelationNodeMap) ByName(name string) (*RelationNode, error) {
	name = strings.ToLower(name)
	for _, fn := range nm {
		if strings.ToLower(fn.Name()) == name {
			return fn, nil
		}
	}

	return nil, errors.New(fmt.Sprintf("Relation node name %v not found", name))
}

func (nm RelationNodeMap) MustByName(name string) (n *RelationNode) {
	n, err := nm.ByName(name)
	if err != nil {
		panic(err)
	}

	return
}

func (nm RelationNodeMap) Each(f func(n *RelationNode)) {
	for _, n := range nm {
		f(n)
	}
}

func (nm RelationNodeMap) FilterFunc(f func(n *RelationNode) bool) (nm0 RelationNodeMap) {
	nm0 = RelationNodeMap{}

	for _, n := range nm {
		if f(n) {
			nm0[n.Id()] = n
		}
	}

	return
}

func (nm RelationNodeMap) HasId(id NodeId) bool {
	_, ok := nm[id]

	return ok
}

func (nm RelationNodeMap) HasName(name string) bool {
	return nm.HasId(ToNodeId(name))
}

func (nm RelationNodeMap) BroadcastSetFlag(name string, v bool) {
	for _, n := range nm {
		n.Flags().Set(name, v)
	}

	return
}

func (nm RelationNodeMap) GetIds() (ids []NodeId) {
	for k, _ := range nm {
		ids = append(ids, k)
	}

	return
}

func (nm RelationNodeMap) Flagged(flag string, b bool) (nm0 RelationNodeMap) {
	nm0 = RelationNodeMap{}

	for k, n := range nm {
		if n.Flags().Is(flag, b) {
			nm0[k] = n
		}
	}

	return
}

func (nm RelationNodeMap) FilterByFlags(subset FlagsSubset) RelationNodeMap {
	if len(subset.Or) != 0 {
		var tfs []string
		for _, f := range subset.Or {
			tfs = append(tfs, string(f))
		}

		nm = nm.FlaggedOr(tfs...)
	}

	if len(subset.And) != 0 {
		for _, f := range subset.And {
			nm = nm.Flagged(string(f), true)
		}
	}

	for _, f := range subset.Nor {
		nm = nm.Flagged(string(f), false)
	}

	if len(nm) == 0 {
		panic("no nodes")
	}

	return nm
}

func (nm RelationNodeMap) FilterByNames(subset NamesSubset) RelationNodeMap {
	if len(subset.Or) != 0 {
		nm = nm.ByNames(subset.Or...)
	}

	if len(subset.Nor) != 0 {
		nm = nm.ExcludeNames(subset.Nor...)
	}

	if len(subset.ContainsOr) != 0 {
		nm = nm.FilterFunc(func(n *RelationNode) bool {
			for _, c := range subset.ContainsOr {
				if strings.Contains(n.Name(), c) {
					return true
				}
			}

			return false
		})
	}

	if len(nm) == 0 {
		panic("no Relations")
	}

	return nm
}

func (nm RelationNodeMap) FlaggedOr(fs ...string) (nm0 RelationNodeMap) {
	nm0 = RelationNodeMap{}

	for k, n := range nm {
		if n.Flags().Or(fs...) {
			nm0[k] = n
		}
	}

	return
}

func (nm RelationNodeMap) BroadcastPrint() {
	for _, n := range nm {
		n.Print()
		println("- - - - - - - - - -")
	}

	return
}

func (nm RelationNodeMap) Slice() (ns RelationNodeSlice) {
	for _, n := range nm {
		ns = append(ns, n)
	}

	return
}

type TypeNodeMap map[NodeId]*TypeNode

func (nm TypeNodeMap) ToNodeMap() (nm0 NodeMap) {
	nm0 = NodeMap{}

	for k, v := range nm {
		nm0[k] = v
	}

	return
}

func (nm TypeNodeMap) UniqueNames() (ns []string) {
	nsm := map[string]bool{}

	for _, v := range nm {
		nsm[v.Name()] = true
	}

	for k, _ := range nsm {
		ns = append(ns, k)
	}

	return
}

func (nm TypeNodeMap) Copy() (nm0 TypeNodeMap) {
	nm0 = TypeNodeMap{}
	for k, v := range nm {
		nm0[k] = v
	}

	return
}

func (nm TypeNodeMap) Filter(s Filter) TypeNodeMap {
	if s.Flags != nil {
		nm = nm.FilterByFlags(*s.Flags)
	}

	if s.Names != nil {
		nm = nm.FilterByNames(*s.Names)
	}

	return nm
}

func (nm TypeNodeMap) Add(ns ...*TypeNode) {
	for _, n := range ns {
		_, ok := nm[n.Id()]
		if ok {
			panic(fmt.Sprintf("TypeNode %v already appended", n.Id()))
		}

		nm[n.Id()] = n
	}
}

func (nm TypeNodeMap) AddTypeNodeMap(nm0 TypeNodeMap) (nm1 TypeNodeMap) {
	nm1 = TypeNodeMap{}

	for _, n := range nm {
		nm1.Add(n)
	}

	for _, n := range nm0 {
		nm1.Add(n)
	}

	return
}

func (nm TypeNodeMap) ExcludeIds(ids ...NodeId) TypeNodeMap {
	not := map[NodeId]bool{}

	for _, id := range ids {
		not[id] = true
	}

	return nm.FilterFunc(func(n *TypeNode) bool {
		_, ok := not[n.Id()]

		return !ok
	})
}

func (nm TypeNodeMap) ExcludeNames(names ...string) TypeNodeMap {
	ids := []NodeId{}
	for _, name := range names {
		ids = append(ids, ToNodeId(name))
	}

	return nm.ExcludeIds(ids...)
}

func (nm TypeNodeMap) ByIds(ids ...NodeId) (filtered TypeNodeMap) {
	filtered = TypeNodeMap{}

	for _, id := range ids {
		filtered[id] = nm.MustById(id)
	}

	return
}

func (nm TypeNodeMap) ByNames(names ...string) TypeNodeMap {
	ids := []NodeId{}
	for _, name := range names {
		ids = append(ids, ToNodeId(name))
	}

	return nm.ByIds(ids...)
}

func (nm TypeNodeMap) ById(id NodeId) (n *TypeNode, err error) {
	n, ok := nm[id]
	if !ok {
		err = errors.New(fmt.Sprintf("Type node id %v not found", id))
	}

	return
}

func (nm TypeNodeMap) MustById(id NodeId) (n *TypeNode) {
	n, err := nm.ById(id)
	if err != nil {
		panic(err)
	}

	return
}

func (nm TypeNodeMap) ByName(name string) (*TypeNode, error) {
	name = strings.ToLower(name)
	for _, fn := range nm {
		if strings.ToLower(fn.Name()) == name {
			return fn, nil
		}
	}

	return nil, errors.New(fmt.Sprintf("Type node name %v not found", name))
}

func (nm TypeNodeMap) MustByName(name string) (n *TypeNode) {
	n, err := nm.ByName(name)
	if err != nil {
		panic(err)
	}

	return
}

func (nm TypeNodeMap) Each(f func(n *TypeNode)) {
	for _, n := range nm {
		f(n)
	}
}

func (nm TypeNodeMap) FilterFunc(f func(n *TypeNode) bool) (nm0 TypeNodeMap) {
	nm0 = TypeNodeMap{}

	for _, n := range nm {
		if f(n) {
			nm0[n.Id()] = n
		}
	}

	return
}

func (nm TypeNodeMap) HasId(id NodeId) bool {
	_, ok := nm[id]

	return ok
}

func (nm TypeNodeMap) HasName(name string) bool {
	return nm.HasId(ToNodeId(name))
}

func (nm TypeNodeMap) BroadcastSetFlag(name string, v bool) {
	for _, n := range nm {
		n.Flags().Set(name, v)
	}

	return
}

func (nm TypeNodeMap) GetIds() (ids []NodeId) {
	for k, _ := range nm {
		ids = append(ids, k)
	}

	return
}

func (nm TypeNodeMap) Flagged(flag string, b bool) (nm0 TypeNodeMap) {
	nm0 = TypeNodeMap{}

	for k, n := range nm {
		if n.Flags().Is(flag, b) {
			nm0[k] = n
		}
	}

	return
}

func (nm TypeNodeMap) FilterByFlags(subset FlagsSubset) TypeNodeMap {
	if len(subset.Or) != 0 {
		var tfs []string
		for _, f := range subset.Or {
			tfs = append(tfs, string(f))
		}

		nm = nm.FlaggedOr(tfs...)
	}

	if len(subset.And) != 0 {
		for _, f := range subset.And {
			nm = nm.Flagged(string(f), true)
		}
	}

	for _, f := range subset.Nor {
		nm = nm.Flagged(string(f), false)
	}

	if len(nm) == 0 {
		panic("no nodes")
	}

	return nm
}

func (nm TypeNodeMap) FilterByNames(subset NamesSubset) TypeNodeMap {
	if len(subset.Or) != 0 {
		nm = nm.ByNames(subset.Or...)
	}

	if len(subset.Nor) != 0 {
		nm = nm.ExcludeNames(subset.Nor...)
	}

	if len(subset.ContainsOr) != 0 {
		nm = nm.FilterFunc(func(n *TypeNode) bool {
			for _, c := range subset.ContainsOr {
				if strings.Contains(n.Name(), c) {
					return true
				}
			}

			return false
		})
	}

	if len(nm) == 0 {
		panic("no Types")
	}

	return nm
}

func (nm TypeNodeMap) FlaggedOr(fs ...string) (nm0 TypeNodeMap) {
	nm0 = TypeNodeMap{}

	for k, n := range nm {
		if n.Flags().Or(fs...) {
			nm0[k] = n
		}
	}

	return
}

func (nm TypeNodeMap) BroadcastPrint() {
	for _, n := range nm {
		n.Print()
		println("- - - - - - - - - -")
	}

	return
}

func (nm TypeNodeMap) Slice() (ns TypeNodeSlice) {
	for _, n := range nm {
		ns = append(ns, n)
	}

	return
}

type PathNodeMap map[NodeId]*PathNode

func (nm PathNodeMap) ToNodeMap() (nm0 NodeMap) {
	nm0 = NodeMap{}

	for k, v := range nm {
		nm0[k] = v
	}

	return
}

func (nm PathNodeMap) UniqueNames() (ns []string) {
	nsm := map[string]bool{}

	for _, v := range nm {
		nsm[v.Name()] = true
	}

	for k, _ := range nsm {
		ns = append(ns, k)
	}

	return
}

func (nm PathNodeMap) Copy() (nm0 PathNodeMap) {
	nm0 = PathNodeMap{}
	for k, v := range nm {
		nm0[k] = v
	}

	return
}

func (nm PathNodeMap) Filter(s Filter) PathNodeMap {
	if s.Flags != nil {
		nm = nm.FilterByFlags(*s.Flags)
	}

	if s.Names != nil {
		nm = nm.FilterByNames(*s.Names)
	}

	return nm
}

func (nm PathNodeMap) Add(ns ...*PathNode) {
	for _, n := range ns {
		_, ok := nm[n.Id()]
		if ok {
			panic(fmt.Sprintf("PathNode %v already appended", n.Id()))
		}

		nm[n.Id()] = n
	}
}

func (nm PathNodeMap) AddPathNodeMap(nm0 PathNodeMap) (nm1 PathNodeMap) {
	nm1 = PathNodeMap{}

	for _, n := range nm {
		nm1.Add(n)
	}

	for _, n := range nm0 {
		nm1.Add(n)
	}

	return
}

func (nm PathNodeMap) ExcludeIds(ids ...NodeId) PathNodeMap {
	not := map[NodeId]bool{}

	for _, id := range ids {
		not[id] = true
	}

	return nm.FilterFunc(func(n *PathNode) bool {
		_, ok := not[n.Id()]

		return !ok
	})
}

func (nm PathNodeMap) ExcludeNames(names ...string) PathNodeMap {
	ids := []NodeId{}
	for _, name := range names {
		ids = append(ids, ToNodeId(name))
	}

	return nm.ExcludeIds(ids...)
}

func (nm PathNodeMap) ByIds(ids ...NodeId) (filtered PathNodeMap) {
	filtered = PathNodeMap{}

	for _, id := range ids {
		filtered[id] = nm.MustById(id)
	}

	return
}

func (nm PathNodeMap) ByNames(names ...string) PathNodeMap {
	ids := []NodeId{}
	for _, name := range names {
		ids = append(ids, ToNodeId(name))
	}

	return nm.ByIds(ids...)
}

func (nm PathNodeMap) ById(id NodeId) (n *PathNode, err error) {
	n, ok := nm[id]
	if !ok {
		err = errors.New(fmt.Sprintf("Path node id %v not found", id))
	}

	return
}

func (nm PathNodeMap) MustById(id NodeId) (n *PathNode) {
	n, err := nm.ById(id)
	if err != nil {
		panic(err)
	}

	return
}

func (nm PathNodeMap) ByName(name string) (*PathNode, error) {
	name = strings.ToLower(name)
	for _, fn := range nm {
		if strings.ToLower(fn.Name()) == name {
			return fn, nil
		}
	}

	return nil, errors.New(fmt.Sprintf("Path node name %v not found", name))
}

func (nm PathNodeMap) MustByName(name string) (n *PathNode) {
	n, err := nm.ByName(name)
	if err != nil {
		panic(err)
	}

	return
}

func (nm PathNodeMap) Each(f func(n *PathNode)) {
	for _, n := range nm {
		f(n)
	}
}

func (nm PathNodeMap) FilterFunc(f func(n *PathNode) bool) (nm0 PathNodeMap) {
	nm0 = PathNodeMap{}

	for _, n := range nm {
		if f(n) {
			nm0[n.Id()] = n
		}
	}

	return
}

func (nm PathNodeMap) HasId(id NodeId) bool {
	_, ok := nm[id]

	return ok
}

func (nm PathNodeMap) HasName(name string) bool {
	return nm.HasId(ToNodeId(name))
}

func (nm PathNodeMap) BroadcastSetFlag(name string, v bool) {
	for _, n := range nm {
		n.Flags().Set(name, v)
	}

	return
}

func (nm PathNodeMap) GetIds() (ids []NodeId) {
	for k, _ := range nm {
		ids = append(ids, k)
	}

	return
}

func (nm PathNodeMap) Flagged(flag string, b bool) (nm0 PathNodeMap) {
	nm0 = PathNodeMap{}

	for k, n := range nm {
		if n.Flags().Is(flag, b) {
			nm0[k] = n
		}
	}

	return
}

func (nm PathNodeMap) FilterByFlags(subset FlagsSubset) PathNodeMap {
	if len(subset.Or) != 0 {
		var tfs []string
		for _, f := range subset.Or {
			tfs = append(tfs, string(f))
		}

		nm = nm.FlaggedOr(tfs...)
	}

	if len(subset.And) != 0 {
		for _, f := range subset.And {
			nm = nm.Flagged(string(f), true)
		}
	}

	for _, f := range subset.Nor {
		nm = nm.Flagged(string(f), false)
	}

	if len(nm) == 0 {
		panic("no nodes")
	}

	return nm
}

func (nm PathNodeMap) FilterByNames(subset NamesSubset) PathNodeMap {
	if len(subset.Or) != 0 {
		nm = nm.ByNames(subset.Or...)
	}

	if len(subset.Nor) != 0 {
		nm = nm.ExcludeNames(subset.Nor...)
	}

	if len(subset.ContainsOr) != 0 {
		nm = nm.FilterFunc(func(n *PathNode) bool {
			for _, c := range subset.ContainsOr {
				if strings.Contains(n.Name(), c) {
					return true
				}
			}

			return false
		})
	}

	if len(nm) == 0 {
		panic("no Paths")
	}

	return nm
}

func (nm PathNodeMap) FlaggedOr(fs ...string) (nm0 PathNodeMap) {
	nm0 = PathNodeMap{}

	for k, n := range nm {
		if n.Flags().Or(fs...) {
			nm0[k] = n
		}
	}

	return
}

func (nm PathNodeMap) BroadcastPrint() {
	for _, n := range nm {
		n.Print()
		println("- - - - - - - - - -")
	}

	return
}

func (nm PathNodeMap) Slice() (ns PathNodeSlice) {
	for _, n := range nm {
		ns = append(ns, n)
	}

	return
}
