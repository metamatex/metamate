// generated by go:generate go run gen/edges.go
package graph

const (
	EndpointForType = "Endpoint,one,Type,For"
	EndpointRequestType = "Endpoint,one,Type,Request"
	EndpointResponseType = "Endpoint,one,Type,Response"
)

type EndpointToTypeEdges struct {
	Resolver EndpointToTypeIdResolver `resolves:"Endpoint,one,Type"`
}


func (e EndpointToTypeEdges) For() (*TypeNode) {
	if e.Resolver.For() == "" {
		return nil
	}

	return e.Resolver.n.root.Types.MustById(e.Resolver.For())
}
func (e EndpointToTypeEdges) Request() (*TypeNode) {
	if e.Resolver.Request() == "" {
		return nil
	}

	return e.Resolver.n.root.Types.MustById(e.Resolver.Request())
}
func (e EndpointToTypeEdges) Response() (*TypeNode) {
	if e.Resolver.Response() == "" {
		return nil
	}

	return e.Resolver.n.root.Types.MustById(e.Resolver.Response())
}

const (
	EnumFilteredByType = "Enum,one,Type,FilteredBy"
)

type EnumToTypeEdges struct {
	Resolver EnumToTypeIdResolver `resolves:"Enum,one,Type"`
}


func (e EnumToTypeEdges) FilteredBy() (*TypeNode) {
	if e.Resolver.FilteredBy() == "" {
		return nil
	}

	return e.Resolver.n.root.Types.MustById(e.Resolver.FilteredBy())
}

const (
	FieldHoldsBasicType = "Field,one,BasicType,Holds"
)

type FieldToBasicTypeEdges struct {
	Resolver FieldToBasicTypeIdResolver `resolves:"Field,one,BasicType"`
}


func (e FieldToBasicTypeEdges) Holds() (*BasicTypeNode) {
	if e.Resolver.Holds() == "" {
		return nil
	}

	return e.Resolver.n.root.BasicTypes.MustById(e.Resolver.Holds())
}

const (
	FieldHoldsEnum = "Field,one,Enum,Holds"
)

type FieldToEnumEdges struct {
	Resolver FieldToEnumIdResolver `resolves:"Field,one,Enum"`
}


func (e FieldToEnumEdges) Holds() (*EnumNode) {
	if e.Resolver.Holds() == "" {
		return nil
	}

	return e.Resolver.n.root.Enums.MustById(e.Resolver.Holds())
}

const (
	FieldForField = "Field,one,Field,For"
	FieldRelatedToField = "Field,one,Field,RelatedTo"
)

type FieldToFieldEdges struct {
	Resolver FieldToFieldIdResolver `resolves:"Field,one,Field"`
}


func (e FieldToFieldEdges) For() (*FieldNode) {
	if e.Resolver.For() == "" {
		return nil
	}

	return e.Resolver.n.root.Fields.MustById(e.Resolver.For())
}
func (e FieldToFieldEdges) RelatedTo() (*FieldNode) {
	if e.Resolver.RelatedTo() == "" {
		return nil
	}

	return e.Resolver.n.root.Fields.MustById(e.Resolver.RelatedTo())
}

const (
	FieldRelatedThroughRelation = "Field,one,Relation,RelatedThrough"
)

type FieldToRelationEdges struct {
	Resolver FieldToRelationIdResolver `resolves:"Field,one,Relation"`
}


func (e FieldToRelationEdges) RelatedThrough() (*RelationNode) {
	if e.Resolver.RelatedThrough() == "" {
		return nil
	}

	return e.Resolver.n.root.Relations.MustById(e.Resolver.RelatedThrough())
}

const (
	FieldHoldsType = "Field,one,Type,Holds"
	FieldHeldByType = "Field,one,Type,HeldBy"
)

type FieldToTypeEdges struct {
	Resolver FieldToTypeIdResolver `resolves:"Field,one,Type"`
}


func (e FieldToTypeEdges) Holds() (*TypeNode) {
	if e.Resolver.Holds() == "" {
		return nil
	}

	return e.Resolver.n.root.Types.MustById(e.Resolver.Holds())
}
func (e FieldToTypeEdges) HeldBy() (*TypeNode) {
	if e.Resolver.HeldBy() == "" {
		return nil
	}

	return e.Resolver.n.root.Types.MustById(e.Resolver.HeldBy())
}

const (
	FieldBelongsToPath = "Field,one,Path,BelongsTo"
)

type FieldToPathEdges struct {
	Resolver FieldToPathIdResolver `resolves:"Field,one,Path"`
}


func (e FieldToPathEdges) BelongsTo() (*PathNode) {
	if e.Resolver.BelongsTo() == "" {
		return nil
	}

	return e.Resolver.n.root.Paths.MustById(e.Resolver.BelongsTo())
}

const (
	RelationNodeAType = "Relation,one,Type,NodeA"
	RelationNodeBType = "Relation,one,Type,NodeB"
)

type RelationToTypeEdges struct {
	Resolver RelationToTypeIdResolver `resolves:"Relation,one,Type"`
}


func (e RelationToTypeEdges) NodeA() (*TypeNode) {
	if e.Resolver.NodeA() == "" {
		return nil
	}

	return e.Resolver.n.root.Types.MustById(e.Resolver.NodeA())
}
func (e RelationToTypeEdges) NodeB() (*TypeNode) {
	if e.Resolver.NodeB() == "" {
		return nil
	}

	return e.Resolver.n.root.Types.MustById(e.Resolver.NodeB())
}

const (
	RelationActivePath = "Relation,one,Path,Active"
	RelationPassivePath = "Relation,one,Path,Passive"
)

type RelationToPathEdges struct {
	Resolver RelationToPathIdResolver `resolves:"Relation,one,Path"`
}


func (e RelationToPathEdges) Active() (*PathNode) {
	if e.Resolver.Active() == "" {
		return nil
	}

	return e.Resolver.n.root.Paths.MustById(e.Resolver.Active())
}
func (e RelationToPathEdges) Passive() (*PathNode) {
	if e.Resolver.Passive() == "" {
		return nil
	}

	return e.Resolver.n.root.Paths.MustById(e.Resolver.Passive())
}

const (
	TypeBelongsToEndpoint = "Type,one,Endpoint,BelongsTo"
	TypeGetEndpoint = "Type,one,Endpoint,Get"
	TypePipeEndpoint = "Type,one,Endpoint,Pipe"
)

type TypeToEndpointEdges struct {
	Resolver TypeToEndpointIdResolver `resolves:"Type,one,Endpoint"`
}


func (e TypeToEndpointEdges) BelongsTo() (*EndpointNode) {
	if e.Resolver.BelongsTo() == "" {
		return nil
	}

	return e.Resolver.n.root.Endpoints.MustById(e.Resolver.BelongsTo())
}
func (e TypeToEndpointEdges) Get() (*EndpointNode) {
	if e.Resolver.Get() == "" {
		return nil
	}

	return e.Resolver.n.root.Endpoints.MustById(e.Resolver.Get())
}
func (e TypeToEndpointEdges) Pipe() (*EndpointNode) {
	if e.Resolver.Pipe() == "" {
		return nil
	}

	return e.Resolver.n.root.Endpoints.MustById(e.Resolver.Pipe())
}

const (
	TypeForEnum = "Type,one,Enum,For"
	TypeListKindEnum = "Type,one,Enum,ListKind"
)

type TypeToEnumEdges struct {
	Resolver TypeToEnumIdResolver `resolves:"Type,one,Enum"`
}


func (e TypeToEnumEdges) For() (*EnumNode) {
	if e.Resolver.For() == "" {
		return nil
	}

	return e.Resolver.n.root.Enums.MustById(e.Resolver.For())
}
func (e TypeToEnumEdges) ListKind() (*EnumNode) {
	if e.Resolver.ListKind() == "" {
		return nil
	}

	return e.Resolver.n.root.Enums.MustById(e.Resolver.ListKind())
}

const (
	TypeForType = "Type,one,Type,For"
	TypeFilteredByType = "Type,one,Type,FilteredBy"
	TypeSortedByType = "Type,one,Type,SortedBy"
	TypeSelectedByType = "Type,one,Type,SelectedBy"
	TypeCollectionType = "Type,one,Type,Collection"
	TypeRequestType = "Type,one,Type,Request"
	TypeResponseType = "Type,one,Type,Response"
	TypeGetRequestType = "Type,one,Type,GetRequest"
	TypeGetCollectionType = "Type,one,Type,GetCollection"
	TypeGetRelationsType = "Type,one,Type,GetRelations"
	TypeGetResponseType = "Type,one,Type,GetResponse"
	TypeGetEndpointType = "Type,one,Type,GetEndpoint"
	TypePipeRequestType = "Type,one,Type,PipeRequest"
	TypePipeResponseType = "Type,one,Type,PipeResponse"
	TypePipeEndpointType = "Type,one,Type,PipeEndpoint"
)

type TypeToTypeEdges struct {
	Resolver TypeToTypeIdResolver `resolves:"Type,one,Type"`
}


func (e TypeToTypeEdges) For() (*TypeNode) {
	if e.Resolver.For() == "" {
		return nil
	}

	return e.Resolver.n.root.Types.MustById(e.Resolver.For())
}
func (e TypeToTypeEdges) FilteredBy() (*TypeNode) {
	if e.Resolver.FilteredBy() == "" {
		return nil
	}

	return e.Resolver.n.root.Types.MustById(e.Resolver.FilteredBy())
}
func (e TypeToTypeEdges) SortedBy() (*TypeNode) {
	if e.Resolver.SortedBy() == "" {
		return nil
	}

	return e.Resolver.n.root.Types.MustById(e.Resolver.SortedBy())
}
func (e TypeToTypeEdges) SelectedBy() (*TypeNode) {
	if e.Resolver.SelectedBy() == "" {
		return nil
	}

	return e.Resolver.n.root.Types.MustById(e.Resolver.SelectedBy())
}
func (e TypeToTypeEdges) Collection() (*TypeNode) {
	if e.Resolver.Collection() == "" {
		return nil
	}

	return e.Resolver.n.root.Types.MustById(e.Resolver.Collection())
}
func (e TypeToTypeEdges) Request() (*TypeNode) {
	if e.Resolver.Request() == "" {
		return nil
	}

	return e.Resolver.n.root.Types.MustById(e.Resolver.Request())
}
func (e TypeToTypeEdges) Response() (*TypeNode) {
	if e.Resolver.Response() == "" {
		return nil
	}

	return e.Resolver.n.root.Types.MustById(e.Resolver.Response())
}
func (e TypeToTypeEdges) GetRequest() (*TypeNode) {
	if e.Resolver.GetRequest() == "" {
		return nil
	}

	return e.Resolver.n.root.Types.MustById(e.Resolver.GetRequest())
}
func (e TypeToTypeEdges) GetCollection() (*TypeNode) {
	if e.Resolver.GetCollection() == "" {
		return nil
	}

	return e.Resolver.n.root.Types.MustById(e.Resolver.GetCollection())
}
func (e TypeToTypeEdges) GetRelations() (*TypeNode) {
	if e.Resolver.GetRelations() == "" {
		return nil
	}

	return e.Resolver.n.root.Types.MustById(e.Resolver.GetRelations())
}
func (e TypeToTypeEdges) GetResponse() (*TypeNode) {
	if e.Resolver.GetResponse() == "" {
		return nil
	}

	return e.Resolver.n.root.Types.MustById(e.Resolver.GetResponse())
}
func (e TypeToTypeEdges) GetEndpoint() (*TypeNode) {
	if e.Resolver.GetEndpoint() == "" {
		return nil
	}

	return e.Resolver.n.root.Types.MustById(e.Resolver.GetEndpoint())
}
func (e TypeToTypeEdges) PipeRequest() (*TypeNode) {
	if e.Resolver.PipeRequest() == "" {
		return nil
	}

	return e.Resolver.n.root.Types.MustById(e.Resolver.PipeRequest())
}
func (e TypeToTypeEdges) PipeResponse() (*TypeNode) {
	if e.Resolver.PipeResponse() == "" {
		return nil
	}

	return e.Resolver.n.root.Types.MustById(e.Resolver.PipeResponse())
}
func (e TypeToTypeEdges) PipeEndpoint() (*TypeNode) {
	if e.Resolver.PipeEndpoint() == "" {
		return nil
	}

	return e.Resolver.n.root.Types.MustById(e.Resolver.PipeEndpoint())
}

const (
	PathBelongsToRelation = "Path,one,Relation,BelongsTo"
)

type PathToRelationEdges struct {
	Resolver PathToRelationIdResolver `resolves:"Path,one,Relation"`
}


func (e PathToRelationEdges) BelongsTo() (*RelationNode) {
	if e.Resolver.BelongsTo() == "" {
		return nil
	}

	return e.Resolver.n.root.Relations.MustById(e.Resolver.BelongsTo())
}

const (
	PathFromType = "Path,one,Type,From"
	PathToType = "Path,one,Type,To"
)

type PathToTypeEdges struct {
	Resolver PathToTypeIdResolver `resolves:"Path,one,Type"`
}


func (e PathToTypeEdges) From() (*TypeNode) {
	if e.Resolver.From() == "" {
		return nil
	}

	return e.Resolver.n.root.Types.MustById(e.Resolver.From())
}
func (e PathToTypeEdges) To() (*TypeNode) {
	if e.Resolver.To() == "" {
		return nil
	}

	return e.Resolver.n.root.Types.MustById(e.Resolver.To())
}

