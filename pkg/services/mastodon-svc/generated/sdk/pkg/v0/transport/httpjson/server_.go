// generated by metactl sdk gen 
package httpjson

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/metamatex/mastodon-svc/generated/sdk/pkg/v0/abstract"
	"github.com/metamatex/mastodon-svc/generated/sdk/pkg/v0/sdk"
	"github.com/metamatex/mastodon-svc/generated/sdk/pkg/v0/utils/ptr"
	"net/http"
	"reflect"
)

type Server struct {
	addr 	string
	server 	*http.Server
	svc		abstract.Service
}

func NewServer(opts ...interface{}) (Server, error) {
	var svc abstract.Service

	for _, opt := range opts {
		switch sth := opt.(type) {
		case abstract.Service:
			if svc != nil {
				panic("only one service can be supplied")
			}
			svc = sth
		default:
			t := reflect.TypeOf(sth)
			panic(fmt.Sprintf("opt %v%v not supported", t.Name(), t.PkgPath()))
		}
	}

	if svc == nil {
		panic("a service needs to be supplied")
	}

	return Server{
		addr: "0.0.0.0:80",
		svc: svc,
	}, nil
}

func (s *Server) Listen() (err error) {
	if s.server != nil {
		err = errors.New("httjson server is already listening")

		return
	}

	s.server = &http.Server{Addr:s.addr, Handler:s}

	err = http.ListenAndServe(s.addr, s)

	return
}

func (s *Server) Close(ctx context.Context) (err error) {
	if s.server == nil {
		err = errors.New("httjson server is not listening")

		return
	}

	err = s.server.Shutdown(ctx)
	if err != nil {
	    return
	}

	s.server = nil

	return
}

func (s Server) send(w http.ResponseWriter, rsp interface{}) (err error) {
	w.Header().Set(CONTENT_TYPE_HEADER, CONTENT_TYPE_JSON)
	w.Header().Set(METAMATE_TYPE_HEADER, reflect.TypeOf(rsp).Name())

	err = json.NewEncoder(w).Encode(rsp)
	if err != nil {
	    return
	}

	return
}

func (s Server) getService() (sdk.Service) {
	getPeopleEndpoint := s.svc.GetGetPeopleEndpoint()
	getStatusesEndpoint := s.svc.GetGetStatusesEndpoint()
	postPeopleEndpoint := s.svc.GetPostPeopleEndpoint()
	putPeopleEndpoint := s.svc.GetPutPeopleEndpoint()

	return sdk.Service{
		Name: ptr.String(s.svc.Name()),
		Endpoints: &sdk.Endpoints{
			GetService: &sdk.GetServiceEndpoint{},
			GetPeople: &getPeopleEndpoint,
			GetStatuses: &getStatusesEndpoint,
			PostPeople: &postPeopleEndpoint,
			PutPeople: &putPeopleEndpoint,
		},
	}
}

func (s Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	switch r.Header.Get(METAMATE_TYPE_HEADER) {
	case sdk.GetServiceRequestName:
			var req sdk.GetServiceRequest
			err := json.NewDecoder(r.Body).Decode(&req)
			if err != nil {
				return
			}
	
			svc := s.getService()
			rsp := sdk.GetServiceResponse{
				Output: &sdk.GetServiceOutput{
					Service: &svc,
				},
			}
	
			err = s.send(w, rsp)
			if err != nil {
				return
			}
    case sdk.GetPeopleRequestName:
        var req sdk.GetPeopleRequest
        err := json.NewDecoder(r.Body).Decode(&req)
        if err != nil {
            return
        }

        rsp := s.svc.GetPeople(r.Context(), req)

        err = s.send(w, rsp)
        if err != nil {
            return
        }
    case sdk.GetStatusesRequestName:
        var req sdk.GetStatusesRequest
        err := json.NewDecoder(r.Body).Decode(&req)
        if err != nil {
            return
        }

        rsp := s.svc.GetStatuses(r.Context(), req)

        err = s.send(w, rsp)
        if err != nil {
            return
        }
    case sdk.PostPeopleRequestName:
        var req sdk.PostPeopleRequest
        err := json.NewDecoder(r.Body).Decode(&req)
        if err != nil {
            return
        }

        rsp := s.svc.PostPeople(r.Context(), req)

        err = s.send(w, rsp)
        if err != nil {
            return
        }
    case sdk.PutPeopleRequestName:
        var req sdk.PutPeopleRequest
        err := json.NewDecoder(r.Body).Decode(&req)
        if err != nil {
            return
        }

        rsp := s.svc.PutPeople(r.Context(), req)

        err = s.send(w, rsp)
        if err != nil {
            return
        }
	}
}