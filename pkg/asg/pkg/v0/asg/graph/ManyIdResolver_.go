// generated by go:generate go run gen/edges.go
package graph

import (
	"fmt"
	"reflect"
	"context"
)

var EndpointToEnumsIdResolver_Dependencies func(context.Context, EndpointToEnumsIdResolver) ([]NodeId)
type EndpointToEnumsIdResolver struct {
	n *EndpointNode
	d  map[string]map[NodeId]bool
}

func NewEndpointToEnumsIdResolver(n *EndpointNode) (EndpointToEnumsIdResolver) {
	return EndpointToEnumsIdResolver{
		n: n,
		d: map[string]map[NodeId]bool{},
	}
}

func (r *EndpointToEnumsIdResolver) add(name string, ids []NodeId) {
	_, ok := r.d[name]
	if !ok {
		r.d[name] = map[NodeId]bool{}
	}

	for _, id := range ids {
		id0, ok := r.d[name][id]
		if ok {
			panic(fmt.Sprintf("%v %v %v already set %v", r.n.Name(), reflect.TypeOf(r).Name(), name, id0))
		}

		r.d[name][id] = true
	}
}

func (r EndpointToEnumsIdResolver) get(name string) (ids []NodeId) {
	for id, _ := range r.d[name] {
		ids = append(ids, id)
	}

	return
}


func (r *EndpointToEnumsIdResolver) AddDependencies(ids ...NodeId) {
	panic(fmt.Sprintf("dynamic egde can not be set to %v", ids))
}

func (r EndpointToEnumsIdResolver) Dependencies()([]NodeId) {
	return r.dependencies(context.Background())
}

func (r EndpointToEnumsIdResolver) dependencies(ctx context.Context)([]NodeId) {
	return EndpointToEnumsIdResolver_Dependencies(ctx, r)
}

var EndpointToTypesIdResolver_Dependencies func(context.Context, EndpointToTypesIdResolver) ([]NodeId)
type EndpointToTypesIdResolver struct {
	n *EndpointNode
	d  map[string]map[NodeId]bool
}

func NewEndpointToTypesIdResolver(n *EndpointNode) (EndpointToTypesIdResolver) {
	return EndpointToTypesIdResolver{
		n: n,
		d: map[string]map[NodeId]bool{},
	}
}

func (r *EndpointToTypesIdResolver) add(name string, ids []NodeId) {
	_, ok := r.d[name]
	if !ok {
		r.d[name] = map[NodeId]bool{}
	}

	for _, id := range ids {
		id0, ok := r.d[name][id]
		if ok {
			panic(fmt.Sprintf("%v %v %v already set %v", r.n.Name(), reflect.TypeOf(r).Name(), name, id0))
		}

		r.d[name][id] = true
	}
}

func (r EndpointToTypesIdResolver) get(name string) (ids []NodeId) {
	for id, _ := range r.d[name] {
		ids = append(ids, id)
	}

	return
}


func (r *EndpointToTypesIdResolver) AddDependencies(ids ...NodeId) {
	panic(fmt.Sprintf("dynamic egde can not be set to %v", ids))
}

func (r EndpointToTypesIdResolver) Dependencies()([]NodeId) {
	return r.dependencies(context.Background())
}

func (r EndpointToTypesIdResolver) dependencies(ctx context.Context)([]NodeId) {
	return EndpointToTypesIdResolver_Dependencies(ctx, r)
}

type RelationToFieldsIdResolver struct {
	n *RelationNode
	d  map[string]map[NodeId]bool
}

func NewRelationToFieldsIdResolver(n *RelationNode) (RelationToFieldsIdResolver) {
	return RelationToFieldsIdResolver{
		n: n,
		d: map[string]map[NodeId]bool{},
	}
}

func (r *RelationToFieldsIdResolver) add(name string, ids []NodeId) {
	_, ok := r.d[name]
	if !ok {
		r.d[name] = map[NodeId]bool{}
	}

	for _, id := range ids {
		id0, ok := r.d[name][id]
		if ok {
			panic(fmt.Sprintf("%v %v %v already set %v", r.n.Name(), reflect.TypeOf(r).Name(), name, id0))
		}

		r.d[name][id] = true
	}
}

func (r RelationToFieldsIdResolver) get(name string) (ids []NodeId) {
	for id, _ := range r.d[name] {
		ids = append(ids, id)
	}

	return
}

func (r *RelationToFieldsIdResolver) AddHolds(ids ...NodeId) (*RelationToFieldsIdResolver) {
	r.add("Holds", ids)

	return r
}

func (r RelationToFieldsIdResolver) Holds()([]NodeId) {
	return r.get("Holds")
}


var TypeToEnumsIdResolver_Dependencies func(context.Context, TypeToEnumsIdResolver) ([]NodeId)
type TypeToEnumsIdResolver struct {
	n *TypeNode
	d  map[string]map[NodeId]bool
}

func NewTypeToEnumsIdResolver(n *TypeNode) (TypeToEnumsIdResolver) {
	return TypeToEnumsIdResolver{
		n: n,
		d: map[string]map[NodeId]bool{},
	}
}

func (r *TypeToEnumsIdResolver) add(name string, ids []NodeId) {
	_, ok := r.d[name]
	if !ok {
		r.d[name] = map[NodeId]bool{}
	}

	for _, id := range ids {
		id0, ok := r.d[name][id]
		if ok {
			panic(fmt.Sprintf("%v %v %v already set %v", r.n.Name(), reflect.TypeOf(r).Name(), name, id0))
		}

		r.d[name][id] = true
	}
}

func (r TypeToEnumsIdResolver) get(name string) (ids []NodeId) {
	for id, _ := range r.d[name] {
		ids = append(ids, id)
	}

	return
}


func (r *TypeToEnumsIdResolver) AddDependencies(ids ...NodeId) {
	panic(fmt.Sprintf("dynamic egde can not be set to %v", ids))
}

func (r TypeToEnumsIdResolver) Dependencies()([]NodeId) {
	return r.dependencies(context.Background())
}

func (r TypeToEnumsIdResolver) dependencies(ctx context.Context)([]NodeId) {
	return TypeToEnumsIdResolver_Dependencies(ctx, r)
}

type TypeToFieldsIdResolver struct {
	n *TypeNode
	d  map[string]map[NodeId]bool
}

func NewTypeToFieldsIdResolver(n *TypeNode) (TypeToFieldsIdResolver) {
	return TypeToFieldsIdResolver{
		n: n,
		d: map[string]map[NodeId]bool{},
	}
}

func (r *TypeToFieldsIdResolver) add(name string, ids []NodeId) {
	_, ok := r.d[name]
	if !ok {
		r.d[name] = map[NodeId]bool{}
	}

	for _, id := range ids {
		id0, ok := r.d[name][id]
		if ok {
			panic(fmt.Sprintf("%v %v %v already set %v", r.n.Name(), reflect.TypeOf(r).Name(), name, id0))
		}

		r.d[name][id] = true
	}
}

func (r TypeToFieldsIdResolver) get(name string) (ids []NodeId) {
	for id, _ := range r.d[name] {
		ids = append(ids, id)
	}

	return
}

func (r *TypeToFieldsIdResolver) AddHolds(ids ...NodeId) (*TypeToFieldsIdResolver) {
	r.add("Holds", ids)

	return r
}

func (r TypeToFieldsIdResolver) Holds()([]NodeId) {
	return r.get("Holds")
}

func (r *TypeToFieldsIdResolver) AddEdgedByFields(ids ...NodeId) (*TypeToFieldsIdResolver) {
	r.add("EdgedByFields", ids)

	return r
}

func (r TypeToFieldsIdResolver) EdgedByFields()([]NodeId) {
	return r.get("EdgedByFields")
}

func (r *TypeToFieldsIdResolver) AddEdgedByListFields(ids ...NodeId) (*TypeToFieldsIdResolver) {
	r.add("EdgedByListFields", ids)

	return r
}

func (r TypeToFieldsIdResolver) EdgedByListFields()([]NodeId) {
	return r.get("EdgedByListFields")
}


type TypeToRelationsIdResolver struct {
	n *TypeNode
	d  map[string]map[NodeId]bool
}

func NewTypeToRelationsIdResolver(n *TypeNode) (TypeToRelationsIdResolver) {
	return TypeToRelationsIdResolver{
		n: n,
		d: map[string]map[NodeId]bool{},
	}
}

func (r *TypeToRelationsIdResolver) add(name string, ids []NodeId) {
	_, ok := r.d[name]
	if !ok {
		r.d[name] = map[NodeId]bool{}
	}

	for _, id := range ids {
		id0, ok := r.d[name][id]
		if ok {
			panic(fmt.Sprintf("%v %v %v already set %v", r.n.Name(), reflect.TypeOf(r).Name(), name, id0))
		}

		r.d[name][id] = true
	}
}

func (r TypeToRelationsIdResolver) get(name string) (ids []NodeId) {
	for id, _ := range r.d[name] {
		ids = append(ids, id)
	}

	return
}

func (r *TypeToRelationsIdResolver) AddHolds(ids ...NodeId) (*TypeToRelationsIdResolver) {
	r.add("Holds", ids)

	return r
}

func (r TypeToRelationsIdResolver) Holds()([]NodeId) {
	return r.get("Holds")
}


var TypeToTypesIdResolver_Misses func(context.Context, TypeToTypesIdResolver) ([]NodeId)
var TypeToTypesIdResolver_Dependencies func(context.Context, TypeToTypesIdResolver) ([]NodeId)
type TypeToTypesIdResolver struct {
	n *TypeNode
	d  map[string]map[NodeId]bool
}

func NewTypeToTypesIdResolver(n *TypeNode) (TypeToTypesIdResolver) {
	return TypeToTypesIdResolver{
		n: n,
		d: map[string]map[NodeId]bool{},
	}
}

func (r *TypeToTypesIdResolver) add(name string, ids []NodeId) {
	_, ok := r.d[name]
	if !ok {
		r.d[name] = map[NodeId]bool{}
	}

	for _, id := range ids {
		id0, ok := r.d[name][id]
		if ok {
			panic(fmt.Sprintf("%v %v %v already set %v", r.n.Name(), reflect.TypeOf(r).Name(), name, id0))
		}

		r.d[name][id] = true
	}
}

func (r TypeToTypesIdResolver) get(name string) (ids []NodeId) {
	for id, _ := range r.d[name] {
		ids = append(ids, id)
	}

	return
}

func (r *TypeToTypesIdResolver) AddToOneRelations(ids ...NodeId) (*TypeToTypesIdResolver) {
	r.add("ToOneRelations", ids)

	return r
}

func (r TypeToTypesIdResolver) ToOneRelations()([]NodeId) {
	return r.get("ToOneRelations")
}

func (r *TypeToTypesIdResolver) AddToManyRelations(ids ...NodeId) (*TypeToTypesIdResolver) {
	r.add("ToManyRelations", ids)

	return r
}

func (r TypeToTypesIdResolver) ToManyRelations()([]NodeId) {
	return r.get("ToManyRelations")
}


func (r *TypeToTypesIdResolver) AddMisses(ids ...NodeId) {
	panic(fmt.Sprintf("dynamic egde can not be set to %v", ids))
}

func (r TypeToTypesIdResolver) Misses()([]NodeId) {
	return r.misses(context.Background())
}

func (r TypeToTypesIdResolver) misses(ctx context.Context)([]NodeId) {
	return TypeToTypesIdResolver_Misses(ctx, r)
}

func (r *TypeToTypesIdResolver) AddDependencies(ids ...NodeId) {
	panic(fmt.Sprintf("dynamic egde can not be set to %v", ids))
}

func (r TypeToTypesIdResolver) Dependencies()([]NodeId) {
	return r.dependencies(context.Background())
}

func (r TypeToTypesIdResolver) dependencies(ctx context.Context)([]NodeId) {
	return TypeToTypesIdResolver_Dependencies(ctx, r)
}

