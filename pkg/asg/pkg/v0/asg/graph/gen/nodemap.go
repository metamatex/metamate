package main

import (
	"os"
	"text/template"
)

func main() {
	err := func() (err error) {
		f, err := os.Create("NodeMap_.go")
		if err != nil {
			return
		}
		defer f.Close()

		err = nodeMapTemplate.Execute(f, []string{"BasicType", "Endpoint", "Enum", "Field", "Relation", "Type", "Path"})
		if err != nil {
			return
		}

		return
	}()
	if err != nil {
		panic(err)
	}
}

var nodeMapTemplate = template.Must(template.New("").Parse(
	`// generated by go:generate go run gen/nodemap.go
package graph

import (
	"fmt"
	"errors"
	"strings"
)

{{ range $i, $name := . }}
type {{ $name }}NodeMap map[NodeId]*{{ $name }}Node

func (nm {{ $name }}NodeMap) ToNodeMap() (nm0 NodeMap) {
	nm0 = NodeMap{}

	for k, v := range nm {
		nm0[k] = v
	}

	return
}

func (nm {{ $name }}NodeMap) Copy() (nm0 {{ $name }}NodeMap) {
	nm0 = {{ $name }}NodeMap{}
	for k,v := range nm {
		nm0[k] = v
	}
	
	return 
}

func (nm {{ $name }}NodeMap) Filter(s Filter) ({{ $name }}NodeMap) {
	if s.Flags != nil {
		nm = nm.FilterByFlags(*s.Flags)
	}

	if s.Names != nil {
		nm = nm.FilterByNames(*s.Names)
	}

	return nm
}

func (nm {{ $name }}NodeMap) Add(ns ...*{{ $name }}Node) {
	for _, n := range ns {
		_, ok := nm[n.Id()]
		if ok {
			panic(fmt.Sprintf("{{ $name }}Node %v already appended", n.Id()))
		}

		nm[n.Id()] = n
	}
}

func (nm {{ $name }}NodeMap) Add{{ $name }}NodeMap(nm0 {{ $name }}NodeMap) (nm1 {{ $name }}NodeMap) {
	nm1 = {{ $name }}NodeMap{}
	
	for _, n := range nm {
		nm1.Add(n)
	}

	for _, n := range nm0 {
		nm1.Add(n)
	}
	
	return 
}

func (nm {{ $name }}NodeMap) ExcludeIds(ids ...NodeId) ({{ $name }}NodeMap) {
	not := map[NodeId]bool{}

	for _, id := range ids {
		not[id] = true
	}

	return nm.FilterFunc(func(n *{{ $name }}Node) bool {
		_, ok := not[n.Id()]

		return !ok
	})
}

func (nm {{ $name }}NodeMap) ExcludeNames(names ...string) ({{ $name }}NodeMap) {
	ids := []NodeId{}
	for _, name := range names {
		ids = append(ids, ToNodeId(name))
	}

	return nm.ExcludeIds(ids...)
}

func (nm {{ $name }}NodeMap) ByIds(ids ...NodeId) (filtered {{ $name }}NodeMap) {
	filtered = {{ $name }}NodeMap{}

	for _, id := range ids {
		filtered[id] = nm.MustById(id)
	}

	return
}

func (nm {{ $name }}NodeMap) ByNames(names ...string) ({{ $name }}NodeMap) {
	ids := []NodeId{}
	for _, name := range names {
		ids = append(ids, ToNodeId(name))
	}
	
	return nm.ByIds(ids...)
}

func (nm {{ $name }}NodeMap) ById(id NodeId) (n *{{ $name }}Node, err error) {
	n, ok := nm[id]
	if !ok {
		err = errors.New(fmt.Sprintf("{{ $name }} node id %v not found", id))
	}

	return
}

func (nm {{ $name }}NodeMap) MustById(id NodeId) (n *{{ $name }}Node) {
	n, err := nm.ById(id)
	if err != nil {
		panic(err)
	}

	return
}

func (nm {{ $name }}NodeMap) ByName(name string) (*{{ $name }}Node, error) {
	return nm.ById(ToNodeId(name))
}

func (nm {{ $name }}NodeMap) MustByName(name string) (*{{ $name }}Node) {
	return nm.MustById(ToNodeId(name))
}

func (nm {{ $name }}NodeMap) Each(f func(n *{{ $name }}Node)) () {
	for _, n := range nm {
		f(n)
	}
}

func (nm {{ $name }}NodeMap) FilterFunc(f func(n *{{ $name }}Node)(bool)) (nm0 {{ $name }}NodeMap) {
	nm0 = {{ $name }}NodeMap{}

	for _, n := range nm {
		if f(n) {
			nm0[n.Id()] = n
		}
	}

	return
}

func (nm {{ $name }}NodeMap) HasId(id NodeId) (bool) {
	_, ok := nm[id]

	return ok
}

func (nm {{ $name }}NodeMap) HasName(name string) (bool) {
	return nm.HasId(ToNodeId(name))
}

func (nm {{ $name }}NodeMap) BroadcastSetFlag(name string, v bool) () {
	for _, n := range nm {
		n.Flags().Set(name, v)
	}

	return
}

func (nm {{ $name }}NodeMap) GetIds() (ids []NodeId) {
	for k, _ := range nm {
		ids = append(ids, k)
	}

	return
}

func (nm {{ $name }}NodeMap) Flagged(flag string, b bool) (nm0 {{ $name }}NodeMap) {
	nm0 = {{ $name }}NodeMap{}

	for k, n := range nm {
		if n.Flags().Is(flag, b) {
			nm0[k] = n
		}
	}

	return
}

func (nm {{ $name }}NodeMap) FilterByFlags(subset FlagsSubset) ({{ $name }}NodeMap) {
	if len(subset.Or) != 0 {
		var tfs []string
		for _, f := range subset.Or {
			tfs = append(tfs, string(f))
		}

		nm = nm.FlaggedOr(tfs...)
	}

	if len(subset.And) != 0 {
		for _, f := range subset.And {
			nm = nm.Flagged(string(f), true)
		}
	}

	for _, f := range subset.Nor {
		nm = nm.Flagged(string(f), false)
	}

	if len(nm) == 0 {
		panic("no nodes")
	}

	return nm
}

func (nm {{ $name }}NodeMap) FilterByNames(subset NamesSubset) ({{ $name }}NodeMap) {
	if len(subset.Or) != 0 {
		nm = nm.ByNames(subset.Or...)
	}

	if len(subset.Nor) != 0 {
		nm = nm.ExcludeNames(subset.Nor...)
	}

	if len(subset.ContainsOr) != 0 {
		nm = nm.FilterFunc(func(n *{{ $name }}Node) bool {
			for _, c := range subset.ContainsOr {
				if strings.Contains(n.Name(), c) {
					return true
				}
			}

			return false
		})
	}

	if len(nm) == 0 {
		panic("no {{ $name }}s")
	}

	return nm
}

func (nm {{ $name }}NodeMap) FlaggedOr(fs ...string) (nm0 {{ $name }}NodeMap) {
	nm0 = {{ $name }}NodeMap{}

	for k, n := range nm {
		if n.Flags().Or(fs...) {
			nm0[k] = n
		}
	}

	return
}

func (nm {{ $name }}NodeMap) BroadcastPrint() () {
	for _, n := range nm {
		n.Print()
		println("- - - - - - - - - -")
	}

	return
}

func (nm {{ $name }}NodeMap) Slice() (ns {{ $name }}NodeSlice) {
	for _, n := range nm {
		ns = append(ns, n)
	}

	return
}
{{ end }}`))
